diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 2c8929a44122..1b1a7ef85e3a 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -496,4 +496,5 @@ source "drivers/misc/ocxl/Kconfig"
 source "drivers/misc/cardreader/Kconfig"
 source "drivers/misc/habanalabs/Kconfig"
 source "drivers/misc/uacce/Kconfig"
+source "drivers/misc/ipts/Kconfig"
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index aecaaed87a35..c8975a65dbcc 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -58,3 +58,4 @@ obj-$(CONFIG_UACCE)		+= uacce/
 obj-$(CONFIG_XILINX_SDFEC)	+= xilinx_sdfec.o
 obj-$(CONFIG_HISI_HIKEY_USB)	+= hisi_hikey_usb.o
 obj-$(CONFIG_UID_SYS_STATS)	+= uid_sys_stats.o
+obj-$(CONFIG_MISC_IPTS)    += ipts/
diff --git a/drivers/misc/ipts/Kconfig b/drivers/misc/ipts/Kconfig
new file mode 100644
index 000000000000..83e2a930c396
--- /dev/null
+++ b/drivers/misc/ipts/Kconfig
@@ -0,0 +1,17 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+config MISC_IPTS
+	tristate "Intel Precise Touch & Stylus"
+	depends on INTEL_MEI
+	help
+	  Say Y here if your system has a touchscreen using Intels
+	  Precise Touch & Stylus (IPTS) technology.
+
+	  If unsure say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ipts.
+
+	  Building this driver alone will not give you a working touchscreen.
+	  It only exposed a userspace API that can be used by a daemon to
+	  receive and process data from the touchscreen hardware.
diff --git a/drivers/misc/ipts/Makefile b/drivers/misc/ipts/Makefile
new file mode 100644
index 000000000000..f7bac66c918c
--- /dev/null
+++ b/drivers/misc/ipts/Makefile
@@ -0,0 +1,16 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# Makefile for the IPTS touchscreen driver
+#
+
+obj-$(CONFIG_MISC_IPTS) += ipts.o
+ipts-objs := control.o
+ipts-objs += mei.o
+ipts-objs += receiver.o
+ipts-objs += resources.o
+ipts-objs += uapi.o
+ipts-objs += contact.o
+ipts-objs += heatmap.o
+ipts-objs += input_device.o
+ipts-objs += touch-processing.o
+ipts-objs += math.o
diff --git a/drivers/misc/ipts/config.h b/drivers/misc/ipts/config.h
new file mode 100644
index 000000000000..3d48365efcf1
--- /dev/null
+++ b/drivers/misc/ipts/config.h
@@ -0,0 +1,21 @@
+// Copyright 2021 The FydeOS Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef _IPTS_CONFIG_H_
+#define _IPTS_CONFIG_H_
+
+struct surface_touch_config {
+  u16 vendor_id;
+  u16 product_id;
+  char name[32];
+  bool invert_x;
+  bool invert_y;
+  u32 width;
+  u32 height;
+  bool block_on_palm;
+  int touch_threshold;
+  int stability_threshold;
+};
+
+#endif /* _IPTS_CONFIG_H_ */
diff --git a/drivers/misc/ipts/contact.c b/drivers/misc/ipts/contact.c
new file mode 100644
index 000000000000..00bfbe735c00
--- /dev/null
+++ b/drivers/misc/ipts/contact.c
@@ -0,0 +1,256 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/timekeeping.h>
+
+#include "contact.h"
+#include "heatmap.h"
+#include "math.h"
+#define MAX_SLOTS 10
+
+static void cluster_add(struct cluster *c, int x, int y, int w)
+{
+	c->x += w * x;
+	c->y += w * y;
+	c->w += w;
+  c->area++;
+  if (c->max_x < x)
+    c->max_x = x;
+  if (c->max_y < y)
+    c->max_y = y;
+  if (c->min_x > x)
+    c->min_x = x;
+  if (c->min_y > y)
+    c->min_y = y;
+
+	if (c->max_v < w)
+		c->max_v = w;
+}
+
+static void cluster_mean(struct cluster *c, int *x, int *y)
+{
+	*x = fix_div_long_round(c->x * 100, c->w);
+	*y = fix_div_long_round(c->y * 100, c->w);
+}
+
+bool add_to_surface_test_palm(struct tp_surface *tp, int x, int y)
+{
+  if (tp->pt == PALM_AREA_THRESHOLD) // if a touch surface's area is above PALM_AREA_THRESHOLD, it is a plam.
+    return true;
+  tp->info[tp->pt].x = x;
+  tp->info[tp->pt].y = y;
+  tp->pt++;
+  return false;
+}
+
+bool pop_from_surface(struct tp_surface *tp, int *x, int *y)
+{
+  if(tp->pt < 1)
+    return false;
+  tp->pt--;
+  *x = tp->info[tp->pt].x;
+  *y = tp->info[tp->pt].y;
+  return true;
+}
+
+static void __cluster_get(struct heatmap *hm, int x, int y, struct cluster *c, struct tp_surface *tp, uint8_t *index)
+{
+	int v = heatmap_value(hm, x, y);
+
+	if (!heatmap_is_touch(hm, x, y)) {
+    heatmap_set_visited(hm, x, y, VISITED_INDEX);
+		return;
+  }
+	if (heatmap_get_visited(hm, x, y))
+		return;
+
+	cluster_add(c, x, y, v);
+  if(add_to_surface_test_palm(tp, x ,y)) // set the palm touch to 0xFF, we don't transfer it to a contact.
+    *index = PALM_INDEX;
+	heatmap_set_visited(hm, x, y, *index);
+
+	__cluster_get(hm, x + 1, y, c, tp, index);
+	__cluster_get(hm, x - 1, y, c, tp, index);
+	__cluster_get(hm, x, y + 1, c, tp, index);
+	__cluster_get(hm, x, y - 1, c, tp, index);
+}
+
+void reset_cluster(struct cluster *c) {
+  memset(c, 0 ,sizeof(struct cluster));
+  c->min_x = MAX_INT;
+  c->min_y = MAX_INT;
+}
+
+static void cluster_get(struct heatmap *hm, int x, int y, struct cluster *c, struct tp_surface *tp, uint8_t *touch_index)
+{
+ 
+  reset_cluster(c);
+  tp->pt = 0;
+	__cluster_get(hm, x, y, c, tp, touch_index);
+
+}
+
+void contact_from_cluster(struct cluster *cluster, struct contact *c, uint8_t index)
+{
+
+	cluster_mean(cluster, &c->x, &c->y);
+
+	c->max_v = cluster->max_v;
+  c->area = cluster->area;
+  c->index = index;
+  c->slot = index;
+  c->major = fix_hypot(cluster->max_x - cluster->min_x, cluster->max_y - cluster->min_y);
+}
+
+int find_trace_index(struct heatmap *last_hm, struct tp_surface *tp)
+{
+  int i;
+  uint8_t touch_index;
+  for ( i=0; i< tp->pt; i++) {
+    touch_index = heatmap_get_visited(last_hm, tp->info[i].x, tp->info[i].y);
+    if (touch_index && touch_index != VISITED_INDEX)
+      return touch_index;
+  }
+  return 0;
+}
+
+void refill_touch(struct heatmap *hm, struct tp_surface *tp, uint8_t index)
+{
+  int x,y;
+  while(pop_from_surface(tp, &x, &y))
+    heatmap_set_visited(hm, x, y, index);
+}
+
+struct tp_surface* reset_surface(struct tp_surface* tp) {
+  tp->pt = 0;
+  return tp;
+}
+
+struct tp_surface *tp_stack = NULL;
+
+void release_contact_buff() {
+  if (tp_stack != NULL)
+    kfree(tp_stack);
+}
+
+int setup_contact_buff() {
+  if (tp_stack == NULL) {
+     tp_stack = kmalloc(sizeof(struct tp_surface) * MAX_SLOTS, GFP_KERNEL);
+     if (!tp_stack)
+       return -ENOMEM;
+   }
+   return 0;
+}
+
+#ifdef DEBUG
+void dump_slots(uint8_t *slots) {
+  pr_info("slots:[%u,%u,%u,%u,%u\n       %u,%u,%u,%u,%u]\n",
+    slots[0],slots[1],slots[2],slots[3],slots[4],
+    slots[5],slots[6],slots[7],slots[8],slots[9]);  
+}
+
+void dump_tp_hm(struct tp_surface *tp, struct heatmap *hm) {
+  int i;
+  for (i = 0; i < tp->pt; i++)
+    pr_info("tp (%d,%d, hm visited:%u)\n", tp->info[i].x, tp->info[i].y, 
+          heatmap_get_visited(hm,tp->info[i].x, tp->info[i].y));  
+}
+#endif
+
+int get_new_slot(uint8_t *slots) {
+  int i;
+  for (i=0; i<MAX_SLOTS;i++)
+    if (slots[i] == 0){
+      slots[i] = 1;
+      return i;
+    }
+  return MAX_SLOTS;  
+}
+
+uint8_t contacts_get(struct heatmap *hm, struct heatmap *last_hm, struct contact *contacts, int count)
+{
+	int i, x, y;
+  uint8_t c = 1;
+  struct cluster cluster;
+  uint8_t index;
+  uint8_t slot_handled[MAX_SLOTS];
+  struct contact* c_stack[MAX_SLOTS];
+  struct tp_surface *tp;
+  int stack_pt = 0;
+  uint8_t touch_index;
+	if (count == 0)
+		return 0;
+  memset(hm->visited, 0, hm->size);
+  memset(slot_handled, 0, MAX_SLOTS);
+  tp = reset_surface(&tp_stack[0]);
+  if (!hm->data)
+    goto end;
+	for (x = 0; x < hm->width; x++) {
+		for (y = 0; y < hm->height; y++) {
+			if (!heatmap_is_touch(hm, x, y))
+				continue;
+
+			if (heatmap_get_visited(hm, x, y))
+				continue;
+      touch_index = c;
+			cluster_get(hm, x, y, &cluster, tp, &touch_index);
+      if (cluster.area) {  // there is a real touch
+        if (touch_index == PALM_INDEX) {  //the touch is palm
+          refill_touch(hm, tp, PALM_INDEX); 
+          continue;
+        }
+        index = find_trace_index(last_hm, tp); //trace the history.
+        if (index == PALM_INDEX){  //it is a palm
+          refill_touch(hm, tp, PALM_INDEX);
+          continue;
+        }
+        if (index) {  //it is in a serial touches.
+          if (index != c) 
+            refill_touch(hm, tp, (uint8_t)index);
+#ifdef DEBUG
+          dump_tp_hm(tp, last_hm);
+          pr_info("trace touch index:%u", index);
+#endif
+          slot_handled[index-1] = 1;
+			    contact_from_cluster(&cluster, &contacts[c - 1], index-1);
+        }else { // it is a new touch
+          contact_from_cluster(&cluster, &contacts[c - 1], c - 1);
+          c_stack[stack_pt] = &contacts[c - 1];
+          stack_pt++;
+          tp = reset_surface(&tp_stack[stack_pt]);
+        }
+#ifdef DEBUG
+          pr_info("touch index:%d, (%d,%d)\n", c, contacts[c - 1].x, contacts[c - 1].y);
+#endif
+        c++;
+      }
+
+			if (c > count)
+				break;
+		}
+	}
+  for (i = 0; i<stack_pt; i++) {
+    x = get_new_slot(slot_handled);
+#ifdef DEBUG
+    pr_info("get new touch index:%d\n", x + 1);
+#endif
+    c_stack[i]->slot = x;
+    c_stack[i]->index = x;
+    refill_touch(hm, &tp_stack[i], (uint8_t) x + 1); //record for history trace.
+    reset_surface(&tp_stack[i]);
+  }
+#ifdef DEBUG
+  dump_slots(slot_handled);
+#endif
+end:
+  c--; //restore the real count of contacts.
+  for (i = c; i < count; i++){
+    x = get_new_slot(slot_handled);
+    //reset the non touch slots;
+    contacts[i].slot = x;
+    contacts[i].index = -1;
+    contacts[i].area = 0;
+  }
+  hm->touch_count = c;
+	return c;
+}
diff --git a/drivers/misc/ipts/contact.h b/drivers/misc/ipts/contact.h
new file mode 100644
index 000000000000..c3ccc1d2f933
--- /dev/null
+++ b/drivers/misc/ipts/contact.h
@@ -0,0 +1,53 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTSD_CONTACT_H_
+#define _IPTSD_CONTACT_H_
+
+#include <linux/types.h>
+
+#include "heatmap.h"
+
+#define PALM_AREA_THRESHOLD 35
+#define PALM_INDEX 0xfe
+#define VISITED_INDEX 0xff
+
+struct hm_info {
+  int x;
+  int y;
+};
+
+struct tp_surface {
+  int pt;  
+  struct hm_info info[PALM_AREA_THRESHOLD];
+};
+
+struct cluster {
+	long x;
+	long y;
+	long w;
+	long max_v;
+  int area;
+  int max_x;
+  int max_y;
+  int min_x;
+  int min_y;
+};
+
+struct contact {
+	/* center */
+	int x;
+	int y;
+  int slot;
+  int index;
+	int max_v;
+  int major;
+  int area;
+  bool is_stable;
+};
+
+uint8_t contacts_get(struct heatmap *hm, struct heatmap *last_hm,  struct contact *contacts, int count);
+
+void release_contact_buff(void);
+int setup_contact_buff(void);
+
+#endif /* _IPTSD_CONTACT_H_ */
diff --git a/drivers/misc/ipts/context.h b/drivers/misc/ipts/context.h
new file mode 100644
index 000000000000..03aeebf73a36
--- /dev/null
+++ b/drivers/misc/ipts/context.h
@@ -0,0 +1,71 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef _IPTS_CONTEXT_H_
+#define _IPTS_CONTEXT_H_
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/input.h>
+#include <linux/cdev.h>
+#include <linux/mei_cl_bus.h>
+
+#include "protocol.h"
+#include "input_device.h"
+#include "touch-processing.h"
+#include "config.h"
+
+enum ipts_host_status {
+	IPTS_HOST_STATUS_STARTING,
+	IPTS_HOST_STATUS_STARTED,
+	IPTS_HOST_STATUS_STOPPING,
+	IPTS_HOST_STATUS_STOPPED,
+};
+
+enum ipts_request_status {
+  IPTS_IDLE,
+  IPTS_REQUEST_FRAME,
+  IPTS_HANDLE_FRAME,
+};
+
+struct ipts_buffer_info {
+	u8 *address;
+	dma_addr_t dma_address;
+};
+
+struct ipts_context {
+	struct mei_cl_device *cldev;
+	struct device *dev;
+
+	bool restart;
+	enum ipts_host_status status;
+	struct ipts_get_device_info_rsp device_info;
+
+	struct ipts_buffer_info data[IPTS_BUFFERS];
+	struct ipts_buffer_info doorbell;
+
+	struct ipts_buffer_info feedback[IPTS_BUFFERS];
+	struct ipts_buffer_info workqueue;
+	struct ipts_buffer_info host2me;
+  u32 current_doorbell;
+  enum ipts_request_status request_status;
+  struct delayed_work request_work;
+  //struct delayed_work release_touch;
+  struct iptsd_touch_processor tp;
+  struct surface_touch_config *config;
+  struct input_dev *touch_dev;
+  struct input_dev *stylus_dev;
+  
+};
+
+#define REFRESH_DELAY msecs_to_jiffies(30)
+//#define REFERSH_NO_INPUT msecs_to_jiffies(100)
+#define INIT_IPTS_TIMEOUT msecs_to_jiffies(150)
+
+extern bool devmode;
+
+#endif /* _IPTS_CONTEXT_H_ */
diff --git a/drivers/misc/ipts/control.c b/drivers/misc/ipts/control.c
new file mode 100644
index 000000000000..74e66534f988
--- /dev/null
+++ b/drivers/misc/ipts/control.c
@@ -0,0 +1,133 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+//#define DEBUG
+#include <linux/mei_cl_bus.h>
+
+#include "context.h"
+#include "protocol.h"
+#include "resources.h"
+#include "uapi.h"
+
+int ipts_control_send(struct ipts_context *ipts, u32 code, void *payload,
+		      size_t size)
+{
+	int ret;
+	struct ipts_command cmd;
+
+	memset(&cmd, 0, sizeof(struct ipts_command));
+	cmd.code = code;
+
+	if (payload && size > 0)
+		memcpy(&cmd.payload, payload, size);
+  dev_dbg(ipts->dev, "Send command: code:0x%x\n", code);
+	ret = mei_cldev_send(ipts->cldev, (u8 *)&cmd, sizeof(cmd.code) + size);
+	if (ret >= 0)
+		return 0;
+
+	/*
+	 * During shutdown the device might get pulled away from below our feet.
+	 * Dont log an error in this case, because it will confuse people.
+	 */
+	if (ret != -ENODEV || ipts->status != IPTS_HOST_STATUS_STOPPING)
+		dev_err(ipts->dev, "Error while sending: 0x%X:%d\n", code, ret);
+
+	return ret;
+}
+
+int ipts_control_send_feedback(struct ipts_context *ipts, u32 buffer)
+{
+	struct ipts_feedback_cmd cmd;
+
+	memset(&cmd, 0, sizeof(struct ipts_feedback_cmd));
+	cmd.buffer = buffer;
+  dev_dbg(ipts->dev, "Send feedback: buffer:%u\n", buffer);
+	return ipts_control_send(ipts, IPTS_CMD_FEEDBACK, &cmd,
+				 sizeof(struct ipts_feedback_cmd));
+}
+
+int ipts_control_set_feature(struct ipts_context *ipts, u8 report, u8 value)
+{
+	struct ipts_feedback_buffer *feedback;
+
+	memset(ipts->host2me.address, 0, ipts->device_info.feedback_size);
+	feedback = (struct ipts_feedback_buffer *)ipts->host2me.address;
+
+	feedback->cmd_type = IPTS_FEEDBACK_CMD_TYPE_NONE;
+	feedback->data_type = IPTS_FEEDBACK_DATA_TYPE_SET_FEATURES;
+	feedback->buffer = IPTS_HOST2ME_BUFFER;
+	feedback->size = 2;
+	feedback->payload[0] = report;
+	feedback->payload[1] = value;
+
+	return ipts_control_send_feedback(ipts, IPTS_HOST2ME_BUFFER);
+}
+
+int ipts_control_start(struct ipts_context *ipts)
+{
+	if (ipts->status != IPTS_HOST_STATUS_STOPPED)
+		return -EBUSY;
+
+	dev_info(ipts->dev, "Starting IPTS\n");
+	ipts->status = IPTS_HOST_STATUS_STARTING;
+	ipts->restart = false;
+  if (devmode)
+	  ipts_uapi_link(ipts);
+	return ipts_control_send(ipts, IPTS_CMD_GET_DEVICE_INFO, NULL, 0);
+}
+
+int ipts_control_stop(struct ipts_context *ipts)
+{
+	int ret;
+
+	if (ipts->status == IPTS_HOST_STATUS_STOPPING)
+		return -EBUSY;
+
+	if (ipts->status == IPTS_HOST_STATUS_STOPPED)
+		return -EBUSY;
+
+	dev_info(ipts->dev, "Stopping IPTS\n");
+	ipts->status = IPTS_HOST_STATUS_STOPPING;
+  if (devmode)
+	  ipts_uapi_unlink();
+	ipts_resources_free(ipts);
+
+	ret = ipts_control_send_feedback(ipts, 0);
+	if (ret == -ENODEV)
+		ipts->status = IPTS_HOST_STATUS_STOPPED;
+
+	return ret;
+}
+
+int ipts_control_restart(struct ipts_context *ipts)
+{
+	if (ipts->restart)
+		return -EBUSY;
+
+	ipts->restart = true;
+	return ipts_control_stop(ipts);
+}
+
+int ipts_control_reset(struct ipts_context *ipts)
+{
+  int ret;
+  struct ipts_reset_sensor_cmd cmd;
+
+  if (!ipts || ipts->status != IPTS_HOST_STATUS_STARTED)
+    return -ENODEV;
+
+  memset(&cmd, 0, sizeof(struct ipts_reset_sensor_cmd));
+  cmd.type = IPTS_RESET_TYPE_SOFT;
+
+  ret = ipts_control_send(ipts, IPTS_CMD_RESET_SENSOR, &cmd,
+        sizeof(struct ipts_reset_sensor_cmd));
+
+  if (ret)
+    return -EFAULT;
+
+  return 0;
+}
diff --git a/drivers/misc/ipts/control.h b/drivers/misc/ipts/control.h
new file mode 100644
index 000000000000..2ac18c96a78a
--- /dev/null
+++ b/drivers/misc/ipts/control.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef _IPTS_CONTROL_H_
+#define _IPTS_CONTROL_H_
+
+#include <linux/types.h>
+
+#include "context.h"
+
+int ipts_control_send(struct ipts_context *ipts, u32 cmd, void *payload,
+		      size_t size);
+int ipts_control_send_feedback(struct ipts_context *ipts, u32 buffer);
+int ipts_control_set_feature(struct ipts_context *ipts, u8 report, u8 value);
+int ipts_control_start(struct ipts_context *ipts);
+int ipts_control_restart(struct ipts_context *ipts);
+int ipts_control_stop(struct ipts_context *ipts);
+int ipts_control_reset(struct ipts_context *ipts);
+
+#endif /* _IPTS_CONTROL_H_ */
diff --git a/drivers/misc/ipts/heatmap.c b/drivers/misc/ipts/heatmap.c
new file mode 100644
index 000000000000..7ec304f51138
--- /dev/null
+++ b/drivers/misc/ipts/heatmap.c
@@ -0,0 +1,117 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <linux/errno.h>
+#include <linux/slab.h>
+
+#include "math.h"
+#include "heatmap.h"
+
+void heatmap_average(struct heatmap *hm)
+{
+  int i;
+  if (!hm->size || !hm->data)
+    return;
+  hm->average = 0;
+
+	for (i = 0; i < hm->size; i++)
+		hm->average += hm->data[i];
+
+  hm->average = fix_div_round(hm->average, hm->size);
+}
+
+uint8_t heatmap_value(struct heatmap *hm, int x, int y)
+{
+	if (x < 0 || x >= hm->width)
+		return 0;
+
+	if (y < 0 || y >= hm->height)
+		return 0;
+
+	return hm->data[y * hm->width + x] >= hm->average 
+    ? 0 : hm->average - hm->data[y * hm->width + x];
+}
+
+bool heatmap_is_touch(struct heatmap *hm, int x, int y)
+{
+	return heatmap_value(hm, x, y) >= hm->touch_threshold;
+}
+
+bool heatmap_compare(struct heatmap *hm, int x1, int y1, int x2, int y2)
+{
+	int v1 = heatmap_value(hm, x1, y1);
+	int v2 = heatmap_value(hm, x2, y2);
+
+	if (v2 > v1)
+		return false;
+
+	if (v2 < v1)
+		return true;
+
+	if (x2 > x1)
+		return false;
+
+	if (x2 < x1)
+		return true;
+
+	if (y2 > y1)
+		return false;
+
+	if (y2 < y1)
+		return true;
+
+	return y2 == y1;
+}
+
+uint8_t heatmap_get_visited(struct heatmap *hm, int x, int y)
+{
+	if (!hm->visited || x < 0 || x >= hm->width ||
+       y < 0 || y >= hm->height)
+		return 0;
+
+	return hm->visited[y * hm->width + x];
+}
+
+void heatmap_set_visited(struct heatmap *hm, int x, int y, uint8_t value)
+{
+	if (!hm->visited || x < 0 || x >= hm->width ||
+       y < 0 || y >= hm->height)
+    return;
+
+	hm->visited[y * hm->width + x] = value;
+}
+
+void heatmap_free(struct heatmap *hm)
+{
+  if(!hm || !hm->visited)
+    return;
+  kfree(hm->visited);
+  hm->visited = NULL;
+}
+
+int heatmap_init(struct heatmap *hm, int w, int h, int threshold)
+{
+  hm->data = NULL;
+  hm->touch_threshold = threshold;
+  if (w == hm->width && h == hm->height){
+    memset(hm->visited, 0, hm->size);
+    return 0;
+  }
+  hm->width = w;
+  hm->height = h;
+	hm->size = w * h;
+  hm->diagonal = fix_hypot(w,h);
+  heatmap_free(hm);
+	hm->visited = kzalloc(hm->size, GFP_NOWAIT);
+	if (!hm->visited) {
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+void release_heatmap(struct heatmap *hm){
+  if (!hm)
+    return;
+  heatmap_free(hm);
+  kfree(hm);
+}
+
diff --git a/drivers/misc/ipts/heatmap.h b/drivers/misc/ipts/heatmap.h
new file mode 100644
index 000000000000..b3e4ebc29522
--- /dev/null
+++ b/drivers/misc/ipts/heatmap.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTSD_HEATMAP_H_
+#define _IPTSD_HEATMAP_H_
+#include <linux/types.h>
+
+struct heatmap {
+  uint8_t touch_count;
+  u32 bell;
+	int width;
+	int height;
+	int size;
+	int touch_threshold;
+  int average;
+  int diagonal;
+
+	uint8_t *data;
+	uint8_t *visited;
+};
+
+void heatmap_average(struct heatmap *hm);
+uint8_t heatmap_value(struct heatmap *hm, int x, int y);
+bool heatmap_is_touch(struct heatmap *hm, int x, int y);
+bool heatmap_compare(struct heatmap *hm, int x1, int y1, int x2, int y2);
+uint8_t heatmap_get_visited(struct heatmap *hm, int x, int y);
+void heatmap_set_visited(struct heatmap *hm, int x, int y, uint8_t index);
+int heatmap_init(struct heatmap *hm, int w, int h, int threshold);
+void heatmap_free(struct heatmap *hm);
+void release_heatmap(struct heatmap *hm);
+
+#endif /* _IPTSD_HEATMAP_H_ */
diff --git a/drivers/misc/ipts/input_data.h b/drivers/misc/ipts/input_data.h
new file mode 100644
index 000000000000..4e578244f72d
--- /dev/null
+++ b/drivers/misc/ipts/input_data.h
@@ -0,0 +1,115 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTSD_PROTOCOL_H_
+#define _IPTSD_PROTOCOL_H_
+
+#include <linux/types.h>
+#include "protocol.h"
+
+#define IPTS_DATA_TYPE_PAYLOAD	    0x0
+#define IPTS_DATA_TYPE_ERROR	    0x1
+#define IPTS_DATA_TYPE_VENDOR_DATA  0x2
+#define IPTS_DATA_TYPE_HID_REPORT   0x3
+#define IPTS_DATA_TYPE_GET_FEATURES 0x4
+
+#define IPTS_PAYLOAD_FRAME_TYPE_STYLUS 0x6
+#define IPTS_PAYLOAD_FRAME_TYPE_TOUCH  0x8
+
+#define IPTS_REPORT_TYPE_TOUCH_HEATMAP_DIM 0x403
+#define IPTS_REPORT_TYPE_TOUCH_HEATMAP	   0x425
+#define IPTS_REPORT_TYPE_STYLUS_V1	   0x410
+#define IPTS_REPORT_TYPE_STYLUS_V2	   0x460
+
+#define IPTS_STYLUS_REPORT_MODE_PROX   (1 << 0)
+#define IPTS_STYLUS_REPORT_MODE_TOUCH  (1 << 1)
+#define IPTS_STYLUS_REPORT_MODE_BUTTON (1 << 2)
+#define IPTS_STYLUS_REPORT_MODE_RUBBER (1 << 3)
+
+#define IPTS_SINGLETOUCH_REPORT_ID 0x40
+#define IPTS_SINGLETOUCH_MAX_VALUE (1 << 15)
+
+#define IPTS_MAX_X    9600
+#define IPTS_MAX_Y    7200
+#define IPTS_DIAGONAL 12000
+
+struct ipts_data {
+	uint32_t type;
+	uint32_t size;
+	uint32_t buffer;
+	uint8_t reserved[52];
+} __attribute__((__packed__));
+
+struct ipts_payload {
+	uint32_t counter;
+	uint32_t frames;
+	uint8_t reserved[4];
+} __attribute__((__packed__));
+
+struct ipts_payload_frame {
+	uint16_t index;
+	uint16_t type;
+	uint32_t size;
+	uint8_t reserved[8];
+} __attribute__((__packed__));
+
+struct ipts_report {
+	uint16_t type;
+	uint16_t size;
+} __attribute__((__packed__));
+
+struct ipts_stylus_report {
+	uint8_t elements;
+	uint8_t reserved[3];
+	uint32_t serial;
+} __attribute__((__packed__));
+
+struct ipts_stylus_data_v2 {
+	uint16_t timestamp;
+	uint16_t mode;
+	uint16_t x;
+	uint16_t y;
+	uint16_t pressure;
+	uint16_t altitude;
+	uint16_t azimuth;
+	uint8_t reserved[2];
+} __attribute__((__packed__));
+
+struct ipts_stylus_data_v1 {
+	uint8_t reserved[4];
+	uint8_t mode;
+	uint16_t x;
+	uint16_t y;
+	uint16_t pressure;
+	uint8_t reserved2;
+} __attribute__((__packed__));
+
+struct ipts_singletouch_data {
+	uint8_t touch;
+	uint16_t x;
+	uint16_t y;
+} __attribute__((__packed__));
+
+struct ipts_heatmap_dim {
+	uint8_t height;
+	uint8_t width;
+	uint8_t reserved[6];
+} __attribute__((__packed__));
+
+#define DATA_PT(x) (x->data[GET_BUFF(x)].address)
+#define IPTS_DATA_PT(x) ((struct ipts_data *)DATA_PT(x))
+#define RAW_LEVEL_ONE(x) (DATA_PT(x) + sizeof(struct ipts_data))
+#define IPTS_PAYLOAD_PT(x) ((struct ipts_payload *) RAW_LEVEL_ONE(x))
+#define RAW_LEVEL_TWO(x) (RAW_LEVEL_ONE(x) + sizeof(struct ipts_payload))
+#define IPTS_PAYLOAD_FRAME(x) ((struct ipts_payload_frame *) RAW_LEVEL_TWO(x))
+#define IPTS_HID_PT(x) ((uint8_t *) RAW_LEVEL_TWO(x))
+#define IPTS_SINGLETOUCH_PT(x) ((struct ipts_singletouch_data *) (RAW_LEVEL_TWO(x) + sizeof(uint8_t)))
+#define RAW_LEVEL_THREE(x) (RAW_LEVEL_TWO(x) + sizeof(struct ipts_payload_frame))
+#define RAW_LEVEL_FOUR(x, offset) (RAW_LEVEL_THREE(x) + offset)
+#define IPTS_REPORT_PT(x, offset) ((struct ipts_report *)RAW_LEVEL_FOUR(x, offset))
+#define IPTS_STYLUS_REPORT(x, offset) ((struct ipts_stylus_report *)RAW_LEVEL_FOUR(x, offset))
+#define IPTS_STYLUS_V1_PT(x, offset) ((struct ipts_stylus_data_v1 *)RAW_LEVEL_FOUR(x, offset))
+#define IPTS_STYLUS_V2_PT(x, offset) ((struct ipts_stylus_data_v2 *)RAW_LEVEL_FOUR(x, offset))
+#define IPTS_HEATMAP_DIM_PT(x, offset) ((struct ipts_heatmap_dim *)RAW_LEVEL_FOUR(x, offset))
+#define IPTS_HEATMAP_PT(x, offset) ((struct heatmap *)RAW_LEVEL_FOUR(x, offset))
+
+#endif /* _IPTSD_PROTOCOL_H_ */
diff --git a/drivers/misc/ipts/input_device.c b/drivers/misc/ipts/input_device.c
new file mode 100644
index 000000000000..2ea752b06c68
--- /dev/null
+++ b/drivers/misc/ipts/input_device.c
@@ -0,0 +1,536 @@
+//#define DEBUG
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/slab.h>
+#include "context.h"
+#include "input_data.h"
+#include "input_device.h"
+#include "heatmap.h"
+#include "touch-processing.h"
+#include "math.h"
+#include "config.h"
+#include "contact.h"
+#include "receiver.h"
+#define MAXNAME 32
+
+size_t max_data_size;
+
+bool is_over_boundary(size_t offset) {
+  return max_data_size <= offset;
+}
+
+struct surface_touch_config configs[] = {
+  {
+    .vendor_id = 0x1B96,
+    .product_id = 0x005E,
+    .name = "surface book 1",
+    .invert_x = false,
+    .invert_y = true,
+    .width = 2853,
+    .height = 1902,
+  },{
+    .vendor_id = 0x045E,
+    .product_id = 0x0021,
+    .name = "surface book 2-13",
+    .invert_x = false,
+    .invert_y = true,
+    .width = 2853,
+    .height = 1902,
+  },{
+    .vendor_id = 0x045E,
+    .product_id = 0x0020,
+    .name = "surface book 2-15",
+    .invert_x = false,
+    .invert_y = false,
+    .width = 3171,
+    .height = 2114,  
+  },{
+    .vendor_id = 0x045E,
+    .product_id = 0x09B2,
+    .name = "surface book 3-13",
+    .invert_x = false,
+    .invert_y = true,
+    .width = 2953,
+    .height = 1902,
+  },{
+    .vendor_id = 0x045E,
+    .product_id = 0x09B1,
+    .name = "surface book 3-15",
+    .invert_x = false,
+    .invert_y = false,
+    .width = 3171,
+    .height = 2114,
+  },{
+    .vendor_id = 0x1B96,
+    .product_id = 0x0979,
+    .name = "surface laptop 1-2",
+    .invert_x = false,
+    .invert_y = false,
+    .width = 2853,
+    .height = 1902,
+  },{
+    .vendor_id = 0x045E,
+    .product_id = 0x0983,
+    .name = "surface book 3-13",
+    .invert_x = false,
+    .invert_y = false,
+    .width = 2853,
+    .height = 1902, 
+  },{
+    .vendor_id = 0x045E,
+    .product_id = 0x0984,
+    .name = "surface book 3-15",
+    .invert_x = false,
+    .invert_y = false,
+    .width = 3171,
+    .height = 2114,
+  },{
+    .vendor_id = 0x01B96,
+    .product_id = 0x006A,
+    .name = "surface pro4 a",
+    .invert_x = true,
+    .invert_y = true,
+    .width = 2598,
+    .height = 1732,
+  },{
+    .vendor_id = 0x01B96,
+    .product_id = 0x0021,
+    .name = "surface pro4 b",
+    .invert_x = true,
+    .invert_y = true,
+    .width = 2598,
+    .height = 1732,
+  },{
+    .vendor_id = 0x01B96,
+    .product_id = 0x001F,
+    .name = "surface pro5",
+    .invert_x = true,
+    .invert_y = true,
+    .width = 2598,
+    .height = 1732,
+  },{
+    .vendor_id = 0x045E,
+    .product_id = 0x001F,
+    .name = "surface pro6",
+    .invert_x = true,
+    .invert_y = true,
+    .width = 2598,
+    .height = 1732,
+  },{
+    .vendor_id = 0x045E,
+    .product_id = 0x099F,
+    .name = "surface pro7",
+    .invert_x = true,
+    .invert_y = true,
+    .width = 2598,
+    .height = 1732,
+  },
+};
+
+struct surface_touch_config* get_match_config(u16 vendor, u16 product)
+{
+  int i;
+  struct surface_touch_config *result = NULL;
+  for ( i=0; i< sizeof(configs)/sizeof(struct surface_touch_config); i++) {
+    if (vendor == configs[i].vendor_id && product == configs[i].product_id) {
+      result = &configs[i];
+      break;
+    }
+  }
+  if (!result->touch_threshold)
+    result->touch_threshold = CONTACT_TOUCH_THRESHOLD;
+  if (!result->stability_threshold)
+    result->stability_threshold = CONTACT_STABILITY_THRESHOLD;
+  
+  return result;
+}
+
+static int input_devices_res(int virt, int phys)
+{
+  return fix_div_round(virt * 10, phys);
+}
+
+int init_stylus_device(struct ipts_context *ipts)
+{
+  struct input_dev *stylus;
+  int ret, res_x, res_y;
+  stylus = devm_input_allocate_device(ipts->dev);
+  if (stylus == NULL)
+    return -ENOMEM;
+  stylus->name = kasprintf(GFP_KERNEL, "%s:%s",ipts->config->name, "Stylus");
+  stylus->phys = "intel_mei";
+  stylus->id.bustype = BUS_VIRTUAL;
+  stylus->id.vendor = ipts->device_info.vendor_id;
+  stylus->id.product = ipts->device_info.device_id;
+  stylus->id.version = ipts->device_info.fw_rev;
+  stylus->dev.parent = ipts->dev;
+  stylus->evbit[0] = BIT(EV_ABS) | BIT(EV_KEY);
+  __set_bit(INPUT_PROP_DIRECT, stylus->propbit);
+  __set_bit(INPUT_PROP_POINTER, stylus->propbit);
+  input_set_capability(stylus, EV_KEY, BTN_TOUCH);
+  input_set_capability(stylus, EV_KEY, BTN_STYLUS);
+  input_set_capability(stylus, EV_KEY, BTN_TOOL_PEN);
+  input_set_capability(stylus, EV_KEY, BTN_TOOL_RUBBER);
+  
+  res_x = input_devices_res(IPTS_MAX_X, ipts->config->width);
+  res_y = input_devices_res(IPTS_MAX_Y, ipts->config->height); 
+  
+  input_set_abs_params(stylus, ABS_X, 0, IPTS_MAX_X, 0, 0);
+  input_abs_set_res(stylus, ABS_X, res_x);
+  input_set_abs_params(stylus, ABS_Y, 0, IPTS_MAX_Y, 0, 0);
+  input_abs_set_res(stylus, ABS_Y, res_y);
+  input_set_abs_params(stylus, ABS_MISC, 0, 65535, 0, 0);
+  input_set_abs_params(stylus, ABS_PRESSURE, 0, 4096, 0, 0);
+  ret = input_register_device(stylus);
+  if (ret) {
+    return ret;
+  }
+  ipts->stylus_dev = stylus;
+  return 0;
+}
+
+int init_touch_device(struct ipts_context *ipts)
+{
+  struct input_dev *input; 
+  int ret, res_x, res_y;
+  input  = devm_input_allocate_device(ipts->dev);
+  if (input == NULL)
+    return -ENOMEM;
+  
+  res_x = input_devices_res(IPTS_MAX_X, ipts->config->width);
+  res_y = input_devices_res(IPTS_MAX_Y, ipts->config->height);
+  
+  input->name = kasprintf(GFP_KERNEL, "%s:%s",ipts->config->name, "TouchScreen");
+  input->phys = "intel_mei";
+  input->id.bustype = BUS_VIRTUAL;
+  input->id.vendor = ipts->device_info.vendor_id;
+  input->id.product = ipts->device_info.device_id;
+  input->id.version = ipts->device_info.fw_rev;
+  input->dev.parent = ipts->dev; 
+  input->evbit[0] = BIT(EV_ABS) | BIT(EV_KEY);
+  input_mt_init_slots(input, ipts->device_info.max_contacts,
+			    INPUT_MT_DIRECT); 
+  input_set_capability(input, EV_KEY, BTN_TOUCH);
+  __set_bit(INPUT_PROP_DIRECT, input->propbit);
+  input_set_abs_params(input, ABS_X, 0, IPTS_MAX_X, 0, 0);
+  input_abs_set_res(input, ABS_X, res_x);
+  input_set_abs_params(input, ABS_Y, 0, IPTS_MAX_Y, 0, 0);
+  input_abs_set_res(input, ABS_Y, res_y);
+  input_set_abs_params(input, ABS_MT_TRACKING_ID, 0, ipts->device_info.max_contacts, 0, 0);
+  input_set_abs_params(input, ABS_MT_POSITION_X, 0, IPTS_MAX_X, 0, 0);
+  input_abs_set_res(input, ABS_MT_POSITION_X, res_x);
+  input_set_abs_params(input, ABS_MT_POSITION_Y, 0, IPTS_MAX_Y, 0, 0);
+  input_abs_set_res(input, ABS_MT_POSITION_Y, res_y);
+  input_set_abs_params(input, ABS_PRESSURE, 0, 200, 0, 0);
+  input_set_abs_params(input, ABS_MT_TOOL_TYPE, 0, MT_TOOL_MAX, 0, 0);
+  input_set_abs_params(input, ABS_MT_TOOL_X, 0, IPTS_MAX_X, 0, 0);
+  input_abs_set_res(input, ABS_MT_TOOL_X, res_x);
+  input_set_abs_params(input, ABS_MT_TOOL_Y, 0, IPTS_MAX_Y, 0, 0);
+  input_abs_set_res(input, ABS_MT_TOOL_Y, res_y);
+  input_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0, IPTS_DIAGONAL, 0, 0);
+  input_abs_set_res(input, ABS_MT_TOUCH_MAJOR, input_devices_res(IPTS_DIAGONAL, fix_hypot(ipts->config->width, ipts->config->height)));
+  ret = input_register_device(input);
+  if (ret) {
+    return ret;
+  }
+  ipts->tp.config = ipts->config;
+  ipts->tp.device_info = &ipts->device_info;
+  ret = iptsd_touch_processing_init(&ipts->tp);
+  if (ret) 
+    dev_warn(ipts->dev, "touch process init error, may not support multitouch.\n");
+  ipts->touch_dev = input;
+
+  return 0;
+}
+
+int init_input_devices(struct ipts_context *ipts) 
+{
+  int ret = 0;
+  if (ipts->touch_dev != NULL)
+    return 0;
+  ipts->config = get_match_config(ipts->device_info.vendor_id, ipts->device_info.device_id);
+  if (ipts->config == NULL)
+    return -ENODEV;
+  ret = setup_contact_buff();
+  if (ret) {
+    dev_err(ipts->dev,"No memory for contact buffer\n");
+    return ret;
+  }
+  max_data_size = ipts->device_info.data_size;
+  ret = init_touch_device(ipts);
+  if (ret) {
+    dev_err(ipts->dev, "Error creating touch input device, ret:%d\n", ret);
+    return ret;
+  }
+  ret = init_stylus_device(ipts);
+  if (ret)
+    dev_warn(ipts->dev, "Error creating stylus device, ret:%d\n", ret);
+  return 0;
+}
+
+void remove_input_devices(struct ipts_context *ipts)
+{
+  if (ipts->touch_dev != NULL) {
+    input_unregister_device(ipts->touch_dev);
+    ipts->touch_dev = NULL;
+  } 
+  if (ipts->stylus_dev != NULL) {
+    input_unregister_device(ipts->stylus_dev);
+    ipts->stylus_dev = NULL;
+  }
+  release_contact_buff();
+  iptsd_touch_processing_free(&ipts->tp);
+}
+
+void dump_data(uint8_t *data, size_t offset, size_t size) {
+ #ifdef DEBUG
+  int i;
+  for ( i = 1; i <= size; i++) {
+    printk(KERN_CONT "%2.2x ", data[offset + i]);
+    if ( i % 8 == 0)
+      printk(KERN_CONT "\n");
+  } 
+ #endif
+ return;
+}
+
+int report_hid_single_touch(struct ipts_context *ipts, u8 *data, size_t *offset)
+{
+  struct input_dev *touch = ipts->touch_dev;
+  struct ipts_singletouch_data *sdata;
+  int x,y;
+  uint8_t *report = (uint8_t *) (data + *offset);
+  *offset += sizeof(uint8_t);
+  if (*report != IPTS_SINGLETOUCH_REPORT_ID) {
+    dev_dbg(&touch->dev, "Read reportid:%u, we only handle singletouch inputs", *report);
+    dump_data(data, *offset, sizeof(struct ipts_singletouch_data));
+    return 0; 
+  }
+  sdata = (struct ipts_singletouch_data *) (data + *offset);
+  input_mt_slot(touch, 0);
+  if (sdata->touch) {
+    x = (int) (sdata->x * IPTS_MAX_X / IPTS_SINGLETOUCH_MAX_VALUE);
+    y = (int) (sdata->y * IPTS_MAX_Y / IPTS_SINGLETOUCH_MAX_VALUE);
+    dev_dbg(&touch->dev, "get touch (%u, %u)", x, y);
+    input_event(touch, EV_ABS, ABS_MT_TRACKING_ID, 0);
+    input_event(touch, EV_ABS, ABS_MT_POSITION_X, x);
+    input_event(touch, EV_ABS, ABS_MT_POSITION_Y, y);
+    input_event(touch, EV_ABS, ABS_MT_TOOL_TYPE, MT_TOOL_FINGER);
+    input_event(touch, EV_ABS, ABS_MT_TOOL_X, x);
+    input_event(touch, EV_ABS, ABS_MT_TOOL_Y, y);
+    input_event(touch, EV_KEY, BTN_TOUCH, 1);
+    input_event(touch, EV_ABS, ABS_X, x);
+    input_event(touch, EV_ABS, ABS_Y, y);
+  }else{
+    input_event(touch, EV_ABS, ABS_MT_TRACKING_ID, -1);
+    input_event(touch, EV_KEY, BTN_TOUCH, 0);
+  }
+  input_mt_sync_frame(touch);
+  input_sync(touch);
+  return 0;
+}
+
+int report_tp(struct input_dev *touch, struct iptsd_touch_processor *tp)
+{
+  int i;
+  struct iptsd_touch_input *in;
+  for (i = 0; i<tp->device_info->max_contacts; i++) {
+    in = &tp->inputs[i];
+    input_mt_slot(touch, in->slot);
+    if (i < tp->touch_count) {
+      dev_dbg(&touch->dev, "tp slot:%d, x:%d, y:%d, is_stable:%d, area:%d", in->slot, in->x, in->y, in->is_stable, in->area);
+      input_event(touch, EV_ABS, ABS_MT_TRACKING_ID, in->index);
+      input_event(touch, EV_ABS, ABS_MT_POSITION_X, in->x);
+      input_event(touch, EV_ABS, ABS_MT_POSITION_Y, in->y);
+      input_event(touch, EV_ABS, ABS_MT_TOOL_TYPE, MT_TOOL_FINGER);
+      input_event(touch, EV_ABS, ABS_PRESSURE, in->pressure);
+      input_event(touch, EV_ABS, ABS_MT_TOUCH_MAJOR, in->major);
+    } else {
+      input_event(touch, EV_ABS, ABS_MT_TRACKING_ID, -1);
+    }
+  }
+  return 0;
+}
+
+int report_touch(struct ipts_context *ipts, size_t frame_size, uint8_t *data, size_t offset)
+{
+  size_t size = 0;
+  size_t frame_offset = offset;
+  struct heatmap *hm = NULL;
+  struct ipts_report *report;
+  struct ipts_heatmap_dim *dim;
+  struct input_dev *touch = ipts->touch_dev;
+  struct iptsd_touch_processor *tp = &ipts->tp;
+  while (size < frame_size) {
+    report = (struct ipts_report *) (data + frame_offset);
+    frame_offset += sizeof(struct ipts_report); 
+    switch (report->type) {
+    case IPTS_REPORT_TYPE_TOUCH_HEATMAP_DIM:
+      dim = (struct ipts_heatmap_dim *) (data + frame_offset);
+      dev_dbg(&touch->dev,"ipts report payload:touch:heatmap_dim, width:%u, height:%u\n", dim->width, dim->height);
+      frame_offset += sizeof(struct ipts_heatmap_dim);  
+      hm = iptsd_touch_processing_get_heatmap(tp, dim->width, dim->height);
+      break;
+    case IPTS_REPORT_TYPE_TOUCH_HEATMAP:
+      if (!hm)
+        break;
+      if (hm->size > report->size) {
+        dev_err(&touch->dev, "Got wrong hm size, hm size:%u, report size:%u\n", hm->size, report->size);
+        return 0;
+      }
+      hm->data = data + frame_offset;
+      hm->bell = ipts->current_doorbell;
+      iptsd_touch_processing_inputs(tp, hm);
+      
+      dev_dbg(&touch->dev,"ipts report payload:filter:%d, touch count:%d, bell:%u\n", tp->filter_out, tp->touch_count, ipts->current_doorbell);
+      if(tp->filter_out) {
+        return 0;
+      }
+      report_tp(touch, tp);
+      frame_offset += hm->size;
+      break;
+    default:
+      dev_dbg(&touch->dev,"report touch unknow type:%d, size:%llu\n", report->type, report->size);
+      dump_data(data, frame_offset, report->size);
+      frame_offset += report->size;
+      if(is_over_boundary(frame_offset)) {
+        dev_err(&touch->dev, "The touchscreen's offset is out of boundary. offset:%u\n", frame_offset); 
+        return 0;
+      }
+    }
+    size += report->size + sizeof(struct ipts_report); 
+  }
+  
+  input_mt_sync_frame(touch);
+  input_sync(touch);
+  return 0;
+}
+
+void stylus_data_v1_to_v2(struct ipts_stylus_data_v1 *v1, struct ipts_stylus_data_v2 *v2)
+{
+  v2->mode = v1->mode;
+  v2->x = v1->x;
+  v2->y = v1->y;
+  v2->pressure = v1->pressure * 4;
+  v2->altitude = 0;
+  v2->azimuth = 0;
+  v2->timestamp = 0;
+}
+
+void report_stylus_data(struct input_dev *stylus, struct iptsd_touch_processor *tp, struct ipts_stylus_data_v2 *data) 
+{
+  int prox = (data->mode & IPTS_STYLUS_REPORT_MODE_PROX) >> 0;
+  int touch = (data->mode & IPTS_STYLUS_REPORT_MODE_TOUCH) >> 1;
+  int button = (data->mode & IPTS_STYLUS_REPORT_MODE_BUTTON) >> 2;
+  int rubber = (data->mode & IPTS_STYLUS_REPORT_MODE_RUBBER) >> 3;
+  int btn_pen = prox * (1 - rubber);
+  int btn_rubber = prox * rubber;
+  input_event(stylus, EV_KEY, BTN_TOUCH, touch);
+  input_event(stylus, EV_KEY, BTN_TOOL_PEN, btn_pen);
+  input_event(stylus, EV_KEY, BTN_TOOL_RUBBER, btn_rubber);
+  input_event(stylus, EV_KEY, BTN_STYLUS, button);
+  input_event(stylus, EV_ABS, ABS_X, data->x); 
+  input_event(stylus, EV_ABS, ABS_Y, data->y);
+  input_event(stylus, EV_ABS, ABS_PRESSURE, data->pressure);
+  input_event(stylus, EV_ABS, ABS_MISC, data->timestamp);
+  input_mt_sync_frame(stylus);
+  input_sync(stylus);
+}
+
+int report_stylus(struct input_dev *stylus, struct iptsd_touch_processor *tp, size_t frame_size, u8 *data, size_t offset)
+{
+  size_t size = 0;
+  struct ipts_report *report;
+  struct ipts_stylus_report *sreport;
+  struct ipts_stylus_data_v1 *data_v1;
+  struct ipts_stylus_data_v2 *data_v2 = NULL;
+  struct ipts_stylus_data_v2 temp_data_v2;
+  size_t frame_offset = offset;
+  uint8_t i;
+  while (size < frame_size) {
+    report = (struct ipts_report *) (data + frame_offset);
+    frame_offset += sizeof(struct ipts_report);
+    if (report->type == IPTS_REPORT_TYPE_STYLUS_V1 || report->type == IPTS_REPORT_TYPE_STYLUS_V2) {
+      sreport = (struct ipts_stylus_report *) (data + frame_offset);
+      frame_offset += sizeof(struct ipts_stylus_report);
+      for ( i=0; i<sreport->elements; i++) {
+        if (report->type == IPTS_REPORT_TYPE_STYLUS_V1) {
+          dev_dbg(&stylus->dev,"ipts report payload:stylus:v1\n");
+          data_v1 = (struct ipts_stylus_data_v1 *)(data + frame_offset);
+          frame_offset += sizeof(struct ipts_stylus_data_v1);
+          stylus_data_v1_to_v2(data_v1, &temp_data_v2);
+          data_v2 = &temp_data_v2;
+        }else if (report->type == IPTS_REPORT_TYPE_STYLUS_V2) {
+          dev_dbg(&stylus->dev,"ipts report payload:stylus:v2\n");
+          data_v2 = (struct ipts_stylus_data_v2 *)(data + frame_offset);
+          frame_offset += sizeof(struct ipts_stylus_data_v2);
+        }else {
+          break;
+        }
+        if (data_v2){
+          report_stylus_data(stylus, tp, data_v2);
+          data_v2 = NULL;
+        }
+      }
+    }else{
+      frame_offset += report->size; 
+      if(is_over_boundary(frame_offset)) {
+        dev_err(&stylus->dev, "The stylus's offset is out of boundary. offset:%u\n", frame_offset);
+        return 0;
+      } 
+    }
+    size += report->size + sizeof(struct ipts_report);
+  }
+  return 0;
+}
+
+int report_payload(struct ipts_context *ipts, uint8_t *data, size_t *offset)
+{
+  uint32_t i;
+  int ret;
+  struct ipts_payload_frame *frame;
+  struct ipts_payload *payload = (struct ipts_payload *)(data + *offset);
+  *offset += sizeof(struct ipts_payload);
+  for ( i=0; i < payload->frames; i++) {
+    frame = (struct ipts_payload_frame *)(DATA_PT(ipts) + *offset);
+    *offset += sizeof(struct ipts_payload_frame);
+    switch (frame->type) {
+    case IPTS_PAYLOAD_FRAME_TYPE_STYLUS:
+      dev_dbg(ipts->dev,"ipts report payload:stylus\n");
+      ret = report_stylus(ipts->stylus_dev, &ipts->tp, frame->size, data, *offset);
+      break;
+    case IPTS_PAYLOAD_FRAME_TYPE_TOUCH:
+      dev_dbg(ipts->dev,"ipts report payload:touch\n");
+      ret = report_touch(ipts, frame->size, data, *offset); 
+      break;
+    default:
+      dev_dbg(ipts->dev, "Unknow frame type:%u\n", frame->type);
+      *offset += (size_t) frame->size;
+    }
+    if (is_over_boundary(*offset)){
+      dev_dbg(ipts->dev, "over boundry offset:%u\n", *offset);
+      return 0;
+    }
+    if (ret < 0)
+      dev_err(ipts->dev, "Failed to handle payload frame: ret:%d\n", ret);
+  }
+  return 0;
+}
+
+int report_data(struct ipts_context *ipts) 
+{
+  size_t offset = sizeof(struct ipts_data);
+  struct ipts_data* data = IPTS_DATA_PT(ipts);
+  dev_dbg(ipts->dev, "report doorbell:%u\n", ipts->current_doorbell);
+  switch (data->type) {
+  case IPTS_DATA_TYPE_PAYLOAD:
+    dev_dbg(ipts->dev,"ipts report payload.\n");
+    return report_payload(ipts, DATA_PT(ipts), &offset);
+  case IPTS_DATA_TYPE_HID_REPORT:
+    dev_dbg(ipts->dev,"ipts report hid.\n");
+    return report_hid_single_touch(ipts, DATA_PT(ipts), &offset); 
+  default:
+    dev_dbg(ipts->dev, "Failed to parse data type:%d\n", data->type);  
+  }
+  return 0;
+}
diff --git a/drivers/misc/ipts/input_device.h b/drivers/misc/ipts/input_device.h
new file mode 100644
index 000000000000..5ae784f2a7ce
--- /dev/null
+++ b/drivers/misc/ipts/input_device.h
@@ -0,0 +1,19 @@
+// Copyright 2021 The FydeOS Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef _IPTS_INPUT_DEVICE_H_
+#define _IPTS_INPUT_DEVICE_H_
+
+#include <linux/types.h>
+#define CONTACT_STABILITY_THRESHOLD 10
+#define CONTACT_TOUCH_THRESHOLD     10
+
+struct ipts_context;
+
+int init_input_devices(struct ipts_context *ipts);
+
+int report_data(struct ipts_context *ipts);
+
+void remove_input_devices(struct ipts_context *ipts);
+#endif /* _IPTS_INPUT_DEVICE_H_ */
diff --git a/drivers/misc/ipts/math.c b/drivers/misc/ipts/math.c
new file mode 100644
index 000000000000..60733614eb6b
--- /dev/null
+++ b/drivers/misc/ipts/math.c
@@ -0,0 +1,142 @@
+#include "math.h"
+#include <linux/kernel.h>
+/*
+#define FACTOR 100000
+#define TWO_PI (u32)M_PI*FACTOR
+double sqrt(double arg )
+{
+  unsigned long x = (unsigned long)(arg * 1000000.0);
+  x = int_sqrt(x); 
+  return (double)x / 1000.0;
+}
+
+float sqrtf(float arg )
+{
+  unsigned long x = (unsigned long)(arg * 10000.0);
+  x = int_sqrt(x);
+  return (float)x / 100.0;
+}
+
+float hypotf(float x, float y)
+{
+  double r = x*x + y*y;
+  r = sqrt(r);
+  return (float)r;
+}
+
+double sin(double arg)
+{
+  u32 rad = arg * FACTOR;
+
+  return (double)fixp_sin32_rad(rad, TWO_PI);
+}
+
+double cos(double arg)
+{
+  u32 rad = arg * FACTOR;
+  return (double)fixp_cos32_rad(rad, TWO_PI);
+}
+
+double m_arctan(double y, double x) {
+    double theta = y / x;
+    double theta2 = theta * theta;
+    double theta3 = theta2 * theta;
+    double theta5 = theta3 * theta2;
+    double theta7 = theta5 * theta2;
+    double theta9 = theta7 * theta2;
+    return theta - theta3/3 + theta5 /5 - theta7 / 7 + theta9 /9;
+}
+
+double atan2(double y, double x) {
+    if (y == 0 && x == 0)
+      return 0;
+    if (y == 0 && x > 0)
+      return 0;
+    if (y == 0 && x < 0)
+      return M_PI;
+    if (y > 0 && x == 0)
+      return M_PI_2;
+    if (y < 0 && x == 0)
+      return - M_PI_2;
+    if (y > 0 && x > 0){
+        if (y == x)
+          return M_PI_4;
+        if (y > x)
+          return M_PI_2 - m_arctan(x, y);
+    }
+    if (y > 0 && x < 0) {
+        if (y == -x)
+          return M_PI_2 + M_PI_4;
+        if (y > -x)
+          return M_PI_2 + m_arctan(-x, y);
+        return M_PI - m_arctan(y, -x);
+    }
+    if (y < 0 && x < 0) {
+        if (y == x)
+          return - (M_PI_2 + M_PI_4);
+        if (y < x)
+          return - (M_PI_2 + m_arctan(x, y));
+        return - M_PI + m_arctan(-y, -x);
+    }
+    if (y < 0 && x > 0) {
+        if (y == -x)
+          return - M_PI_4;
+        if (-y > x)
+          return - M_PI_2 + m_arctan(x, -y);
+    }
+    return m_arctan(y, x);
+}
+
+float atan2f(float y, float x)
+{
+  return (float)atan2(y,x);
+}
+
+float roundf(float arg)
+{
+    int _ceil = arg;
+    float mid = _ceil + 0.5;
+    return arg >=mid ? _ceil + 1.0 : _ceil;
+}
+
+int32_t fixed_exp2 (int32_t a)
+{
+    int32_t i, f, r, s;
+    i = (a + 0x8000) & ~0xffff; // 0.5
+    f = a - i;   
+    s = ((15 << 16) - i) >> 16;
+    r = 0x00000e20;                 // 5.5171669058037949e-2
+    r = (r * f + 0x3e1cc333) >> 17; // 2.4261112219321804e-1
+    r = (r * f + 0x58bd46a6) >> 16; // 6.9326098546062365e-1
+    r = r * f + 0x7ffde4a3;         // 9.9992807353939517e-1
+    return (uint32_t)r >> s;
+}
+*/
+int fix_hypot(int x, int y)
+{
+  return int_sqrt(x*x + y*y); 
+}
+
+int fix_round(int x){
+  int tmp = x / 10 * 10;
+  if (x >=0) 
+    return x - tmp >= 5 ? tmp + 10 : tmp;
+  return tmp - x >= 5 ? tmp - 10: tmp; 
+}
+
+int fix_div_round(int x, int y)
+{
+  int tmp = x * 10;
+  return fix_round(tmp/y)/10;
+}
+
+int fix_div_long_round(long x, long y)
+{
+  int tmp = x * 10 /y;
+  return fix_round(tmp)/10;
+}
+
+int fix_zoom(int x, int origin_max, int new_max)
+{
+  return fix_div_round( x * new_max, origin_max);
+}
diff --git a/drivers/misc/ipts/math.h b/drivers/misc/ipts/math.h
new file mode 100644
index 000000000000..99d513788102
--- /dev/null
+++ b/drivers/misc/ipts/math.h
@@ -0,0 +1,14 @@
+// Copyright 2021 The FydeOS Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef _IPTS_MATH_H_
+#define _IPTS_MATH_H_
+
+#include <linux/types.h>
+#define MAX_INT    0x7ffffff
+int fix_hypot(int x, int y);
+int fix_div_round(int x, int y);
+int fix_div_long_round(long x, long y);
+int fix_zoom(int x, int origin_max, int new_max);
+#endif /* _IPTS_MATH_H_ */
diff --git a/drivers/misc/ipts/mei.c b/drivers/misc/ipts/mei.c
new file mode 100644
index 000000000000..b3d3d3721e3c
--- /dev/null
+++ b/drivers/misc/ipts/mei.c
@@ -0,0 +1,218 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+//#define DEBUG
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/mei_cl_bus.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include "context.h"
+#include "control.h"
+#include "protocol.h"
+#include "receiver.h"
+#include "input_data.h"
+#include "uapi.h"
+
+#define IPTS_DRV_NAME "ipts"
+
+bool devmode;
+module_param(devmode, bool, 0644);
+
+static int ipts_mei_set_dma_mask(struct mei_cl_device *cldev)
+{
+	int ret;
+
+	ret = dma_coerce_mask_and_coherent(&cldev->dev, DMA_BIT_MASK(64));
+	if (!ret)
+		return 0;
+
+	return dma_coerce_mask_and_coherent(&cldev->dev, DMA_BIT_MASK(32));
+}
+
+static void input_request_dispatch(struct work_struct *work)
+{
+  struct ipts_context *ipts = container_of(to_delayed_work(work),
+             struct ipts_context, request_work);
+  u32 doorbell;
+  int diff;
+  if (ipts->touch_dev == NULL || ipts->request_status != IPTS_REQUEST_FRAME ||
+      ipts->doorbell.address == NULL || ipts->status != IPTS_HOST_STATUS_STARTED
+      ) {
+    dev_dbg(ipts->dev, "Someting wrong: touch:%p, request_status:%d,doorbell:%p, status:%d\n",
+      ipts->touch_dev, ipts->request_status, ipts->doorbell.address, ipts->status);
+    goto end;
+  }
+  doorbell = GET_DOORBELL(ipts);
+  if (ipts->current_doorbell == doorbell) {
+    dev_dbg(ipts->dev, "Same doorbell:%u\n", doorbell);
+    goto end;
+  }
+  ipts->request_status = IPTS_HANDLE_FRAME; 
+  diff = doorbell - ipts->current_doorbell;
+  dev_dbg(ipts->dev, "get new doorbells:%d, target doorbell:%u\n", diff, doorbell);
+  if (diff > 10 || diff < 0){
+    ipts->current_doorbell = doorbell;
+    ipts_receiver_flush(ipts);
+  } else {
+    for (; diff > 0; diff-- ){
+      report_data(ipts);
+      ipts_control_send_feedback(ipts, GET_BUFF(ipts)); 
+      ipts->current_doorbell++; 
+    }
+  }
+  ipts->request_status = IPTS_REQUEST_FRAME;
+  schedule_delayed_work(&ipts->request_work, REFRESH_DELAY);
+  return;
+  
+end:
+  schedule_delayed_work(&ipts->request_work, REFRESH_DELAY);
+}
+
+static int ipts_mei_probe(struct mei_cl_device *cldev,
+			  const struct mei_cl_device_id *id)
+{
+	int ret;
+	struct ipts_context *ipts;
+
+	if (ipts_mei_set_dma_mask(cldev)) {
+		dev_err(&cldev->dev, "Failed to set DMA mask for IPTS\n");
+		return -EFAULT;
+	}
+
+	ret = mei_cldev_enable(cldev);
+	if (ret) {
+		dev_err(&cldev->dev, "Failed to enable MEI device: %d\n", ret);
+		return ret;
+	}
+
+	ipts = kzalloc(sizeof(*ipts), GFP_KERNEL);
+	if (!ipts) {
+		mei_cldev_disable(cldev);
+		return -ENOMEM;
+	}
+
+	ipts->cldev = cldev;
+	ipts->dev = &cldev->dev;
+	ipts->status = IPTS_HOST_STATUS_STOPPED;
+  if (!devmode) {
+    ipts->current_doorbell = 0xFFFF;
+    ipts->request_status = IPTS_IDLE;
+    ipts->touch_dev = NULL;
+    ipts->stylus_dev = NULL;
+    ipts->config = NULL;
+    INIT_DELAYED_WORK(&ipts->request_work, input_request_dispatch);
+  }
+	mei_cldev_set_drvdata(cldev, ipts);
+	ret = mei_cldev_register_rx_cb(cldev, ipts_receiver_callback);
+  if (ret)
+    dev_warn(&cldev->dev,"register rx error:%d ,ipts may not work!", ret);
+  ret = mei_cldev_register_notif_cb(cldev, ipts_mei_notif);
+  if (ret)
+     dev_warn(&cldev->dev,"register notif error:%d", ret);
+  ret = ipts_control_start(ipts);
+  if (ret){
+    dev_err(&cldev->dev, "Error to start ipts, ret:%d\n", ret);
+    return ret;
+  }
+  pr_info("ipts driver probed.");
+	return 0;
+}
+
+static int ipts_mei_remove(struct mei_cl_device *cldev)
+{
+	int i;
+	struct ipts_context *ipts = mei_cldev_get_drvdata(cldev);
+  if (!devmode) {
+    if (ipts->request_status != IPTS_IDLE) {
+      cancel_delayed_work_sync(&ipts->request_work); 
+      ipts->request_status = IPTS_IDLE;
+    }
+    remove_input_devices(ipts);
+  }
+	ipts_control_stop(ipts);
+
+	for (i = 0; i < 20; i++) {
+		if (ipts->status == IPTS_HOST_STATUS_STOPPED)
+			break;
+
+		msleep(25);
+	}
+
+	mei_cldev_disable(cldev);
+	kfree(ipts);
+  pr_info("ipts driver removed.");
+	return 0;
+}
+
+static struct mei_cl_device_id ipts_mei_device_id_table[] = {
+	{ "", IPTS_MEI_UUID, MEI_CL_VERSION_ANY },
+	{},
+};
+MODULE_DEVICE_TABLE(mei, ipts_mei_device_id_table);
+
+#ifdef CONFIG_PM_SLEEP
+static int ipts_suspend(struct device *dev)
+{
+  pr_info ("ipts driver suspend");
+  return 0;
+}
+
+static int ipts_resume(struct device *dev)
+{
+  pr_info("ipts driver resume");
+  return 0;
+}
+static SIMPLE_DEV_PM_OPS(ipts_pm_ops, ipts_suspend, ipts_resume);
+#define IPTS_PM_OPS (&ipts_pm_ops)
+#else
+#define IPTS_PM_OPS NULL
+#endif
+
+static struct mei_cl_driver ipts_mei_driver = {
+  .driver = {
+    .pm = IPTS_PM_OPS,
+  },
+	.id_table = ipts_mei_device_id_table,
+	.name = IPTS_DRV_NAME,
+	.probe = ipts_mei_probe,
+	.remove = ipts_mei_remove,
+};
+
+static int __init ipts_mei_init(void)
+{
+	int ret;
+
+  if (devmode) {
+	  ret = ipts_uapi_init();
+	  if (ret)
+		  return ret;
+  }
+	ret = mei_cldev_driver_register(&ipts_mei_driver);
+	if (ret && devmode) {
+		ipts_uapi_free();
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __exit ipts_mei_exit(void)
+{
+	mei_cldev_driver_unregister(&ipts_mei_driver);
+  if (devmode)
+	  ipts_uapi_free();
+}
+
+MODULE_DESCRIPTION("IPTS touchscreen driver");
+MODULE_AUTHOR("Dorian Stoll <dorian.stoll@tmsp.io>");
+MODULE_LICENSE("GPL");
+
+module_init(ipts_mei_init);
+module_exit(ipts_mei_exit);
diff --git a/drivers/misc/ipts/protocol.h b/drivers/misc/ipts/protocol.h
new file mode 100644
index 000000000000..c8c4dfc11b03
--- /dev/null
+++ b/drivers/misc/ipts/protocol.h
@@ -0,0 +1,350 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef _IPTS_PROTOCOL_H_
+#define _IPTS_PROTOCOL_H_
+
+#include <linux/types.h>
+
+/*
+ * The MEI client ID for IPTS functionality.
+ */
+#define IPTS_MEI_UUID                                                          \
+	UUID_LE(0x3e8d0870, 0x271a, 0x4208, 0x8e, 0xb5, 0x9a, 0xcb, 0x94,      \
+		0x02, 0xae, 0x04)
+
+/*
+ * Queries the device for vendor specific information.
+ *
+ * The command must not contain any payload.
+ * The response will contain struct ipts_get_device_info_rsp as payload.
+ */
+#define IPTS_CMD_GET_DEVICE_INFO 0x00000001
+#define IPTS_RSP_GET_DEVICE_INFO 0x80000001
+
+/*
+ * Sets the mode that IPTS will operate in.
+ *
+ * The command must contain struct ipts_set_mode_cmd as payload.
+ * The response will not contain any payload.
+ */
+#define IPTS_CMD_SET_MODE 0x00000002
+#define IPTS_RSP_SET_MODE 0x80000002
+
+/*
+ * Configures the memory buffers that the ME will use
+ * for passing data to the host.
+ *
+ * The command must contain struct ipts_set_mem_window_cmd as payload.
+ * The response will not contain any payload.
+ */
+#define IPTS_CMD_SET_MEM_WINDOW 0x00000003
+#define IPTS_RSP_SET_MEM_WINDOW 0x80000003
+
+/*
+ * Signals that the host is ready to receive data to the ME.
+ *
+ * The command must not contain any payload.
+ * The response will not contain any payload.
+ */
+#define IPTS_CMD_READY_FOR_DATA 0x00000005
+#define IPTS_RSP_READY_FOR_DATA 0x80000005
+
+/*
+ * Signals that a buffer can be refilled to the ME.
+ *
+ * The command must contain struct ipts_feedback_cmd as payload.
+ * The response will not contain any payload.
+ */
+#define IPTS_CMD_FEEDBACK 0x00000006
+#define IPTS_RSP_FEEDBACK 0x80000006
+
+/*
+ * Resets the data flow from the ME to the hosts and
+ * clears the buffers that were set with SET_MEM_WINDOW.
+ *
+ * The command must not contain any payload.
+ * The response will not contain any payload.
+ */
+#define IPTS_CMD_CLEAR_MEM_WINDOW 0x00000007
+#define IPTS_RSP_CLEAR_MEM_WINDOW 0x80000007
+
+/*
+ * Instructs the ME to reset the touch sensor.
+ *
+ * The command must contain struct ipts_reset_sensor_cmd as payload.
+ * The response will not contain any payload.
+ */
+#define IPTS_CMD_RESET_SENSOR 0x0000000B
+#define IPTS_RSP_RESET_SENSOR 0x8000000B
+
+/**
+ * enum ipts_status - Possible status codes returned by IPTS commands.
+ * @IPTS_STATUS_SUCCESS:                 Operation completed successfully.
+ * @IPTS_STATUS_INVALID_PARAMS:          Command contained a payload with invalid parameters.
+ * @IPTS_STATUS_ACCESS_DENIED:           ME could not validate buffer addresses supplied by host.
+ * @IPTS_STATUS_CMD_SIZE_ERROR:          Command contains an invalid payload.
+ * @IPTS_STATUS_NOT_READY:               Buffer addresses have not been set.
+ * @IPTS_STATUS_REQUEST_OUTSTANDING:     There is an outstanding command of the same type.
+ *                                       The host must wait for a response before sending another
+ *                                       command of the same type.
+ * @IPTS_STATUS_NO_SENSOR_FOUND:         No sensor could be found. Either no sensor is connected, it
+ *                                       has not been initialized yet, or the system is improperly
+ *                                       configured.
+ * @IPTS_STATUS_OUT_OF_MEMORY:           Not enough free memory for requested operation.
+ * @IPTS_STATUS_INTERNAL_ERROR:          An unexpected error occurred.
+ * @IPTS_STATUS_SENSOR_DISABLED:         The sensor has been disabled and must be reinitialized.
+ * @IPTS_STATUS_COMPAT_CHECK_FAIL:       Compatibility revision check between sensor and ME failed.
+ *                                       The host can ignore this error and attempt to continue.
+ * @IPTS_STATUS_SENSOR_EXPECTED_RESET:   The sensor went through a reset initiated by ME or host.
+ * @IPTS_STATUS_SENSOR_UNEXPECTED_RESET: The sensor went through an unexpected reset.
+ * @IPTS_STATUS_RESET_FAILED:            Requested sensor reset failed to complete.
+ * @IPTS_STATUS_TIMEOUT:                 The operation timed out.
+ * @IPTS_STATUS_TEST_MODE_FAIL:          Test mode pattern did not match expected values.
+ * @IPTS_STATUS_SENSOR_FAIL_FATAL:       The sensor reported a fatal error during reset sequence.
+ *                                       Further progress is not possible.
+ * @IPTS_STATUS_SENSOR_FAIL_NONFATAL:    The sensor reported a fatal error during reset sequence.
+ *                                       The host can attempt to continue.
+ * @IPTS_STATUS_INVALID_DEVICE_CAPS:     The device reported invalid capabilities.
+ * @IPTS_STATUS_QUIESCE_IO_IN_PROGRESS:  Command cannot be completed until Quiesce IO is done.
+ */
+enum ipts_status {
+	IPTS_STATUS_SUCCESS = 0,
+	IPTS_STATUS_INVALID_PARAMS = 1,
+	IPTS_STATUS_ACCESS_DENIED = 2,
+	IPTS_STATUS_CMD_SIZE_ERROR = 3,
+	IPTS_STATUS_NOT_READY = 4,
+	IPTS_STATUS_REQUEST_OUTSTANDING = 5,
+	IPTS_STATUS_NO_SENSOR_FOUND = 6,
+	IPTS_STATUS_OUT_OF_MEMORY = 7,
+	IPTS_STATUS_INTERNAL_ERROR = 8,
+	IPTS_STATUS_SENSOR_DISABLED = 9,
+	IPTS_STATUS_COMPAT_CHECK_FAIL = 10,
+	IPTS_STATUS_SENSOR_EXPECTED_RESET = 11,
+	IPTS_STATUS_SENSOR_UNEXPECTED_RESET = 12,
+	IPTS_STATUS_RESET_FAILED = 13,
+	IPTS_STATUS_TIMEOUT = 14,
+	IPTS_STATUS_TEST_MODE_FAIL = 15,
+	IPTS_STATUS_SENSOR_FAIL_FATAL = 16,
+	IPTS_STATUS_SENSOR_FAIL_NONFATAL = 17,
+	IPTS_STATUS_INVALID_DEVICE_CAPS = 18,
+	IPTS_STATUS_QUIESCE_IO_IN_PROGRESS = 19,
+};
+
+/*
+ * The amount of buffers that is used for IPTS
+ */
+#define IPTS_BUFFERS 16
+
+/*
+ * The special buffer ID that is used for direct host2me feedback.
+ */
+#define IPTS_HOST2ME_BUFFER IPTS_BUFFERS
+
+/**
+ * enum ipts_mode - Operation mode for IPTS hardware
+ * @IPTS_MODE_SINGLETOUCH: Fallback that supports only one finger and no stylus.
+ *                         The data is received as a HID report with ID 64.
+ * @IPTS_MODE_MULTITOUCH:  The "proper" operation mode for IPTS. It will return
+ *                         stylus data as well as capacitive heatmap touch data.
+ *                         This data needs to be processed in userspace.
+ */
+enum ipts_mode {
+	IPTS_MODE_SINGLETOUCH = 0,
+	IPTS_MODE_MULTITOUCH = 1,
+};
+
+/**
+ * struct ipts_set_mode_cmd - Payload for the SET_MODE command.
+ * @mode: The mode that IPTS should operate in.
+ */
+struct ipts_set_mode_cmd {
+	enum ipts_mode mode;
+	u8 reserved[12];
+} __packed;
+
+#define IPTS_WORKQUEUE_SIZE	 8192
+#define IPTS_WORKQUEUE_ITEM_SIZE 16
+
+/**
+ * struct ipts_set_mem_window_cmd - Payload for the SET_MEM_WINDOW command.
+ * @data_buffer_addr_lower:     Lower 32 bits of the data buffer addresses.
+ * @data_buffer_addr_upper:     Upper 32 bits of the data buffer addresses.
+ * @workqueue_addr_lower:       Lower 32 bits of the workqueue buffer address.
+ * @workqueue_addr_upper:       Upper 32 bits of the workqueue buffer address.
+ * @doorbell_addr_lower:        Lower 32 bits of the doorbell buffer address.
+ * @doorbell_addr_upper:        Upper 32 bits of the doorbell buffer address.
+ * @feedback_buffer_addr_lower: Lower 32 bits of the feedback buffer addresses.
+ * @feedback_buffer_addr_upper: Upper 32 bits of the feedback buffer addresses.
+ * @host2me_addr_lower:         Lower 32 bits of the host2me buffer address.
+ * @host2me_addr_upper:         Upper 32 bits of the host2me buffer address.
+ * @workqueue_item_size:        Magic value. (IPTS_WORKQUEUE_ITEM_SIZE)
+ * @workqueue_size:             Magic value. (IPTS_WORKQUEUE_SIZE)
+ *
+ * The data buffers are buffers that get filled with touch data by the ME.
+ * The doorbell buffer is a u32 that gets incremented by the ME once a data
+ * buffer has been filled with new data.
+ *
+ * The other buffers are required for using GuC submission with binary
+ * firmware. Since support for GuC submission has been dropped from i915,
+ * they are not used anymore, but they need to be allocated and passed,
+ * otherwise the hardware will refuse to start.
+ */
+struct ipts_set_mem_window_cmd {
+	u32 data_buffer_addr_lower[IPTS_BUFFERS];
+	u32 data_buffer_addr_upper[IPTS_BUFFERS];
+	u32 workqueue_addr_lower;
+	u32 workqueue_addr_upper;
+	u32 doorbell_addr_lower;
+	u32 doorbell_addr_upper;
+	u32 feedback_buffer_addr_lower[IPTS_BUFFERS];
+	u32 feedback_buffer_addr_upper[IPTS_BUFFERS];
+	u32 host2me_addr_lower;
+	u32 host2me_addr_upper;
+	u32 host2me_size;
+	u8 reserved1;
+	u8 workqueue_item_size;
+	u16 workqueue_size;
+	u8 reserved[32];
+} __packed;
+
+/**
+ * struct ipts_feedback_cmd - Payload for the FEEDBACK command.
+ * @buffer: The buffer that the ME should refill.
+ */
+struct ipts_feedback_cmd {
+	u32 buffer;
+	u8 reserved[12];
+} __packed;
+
+/**
+ * enum ipts_feedback_cmd_type - Commands that can be executed on the sensor through feedback.
+ */
+enum ipts_feedback_cmd_type {
+	IPTS_FEEDBACK_CMD_TYPE_NONE = 0,
+	IPTS_FEEDBACK_CMD_TYPE_SOFT_RESET = 1,
+	IPTS_FEEDBACK_CMD_TYPE_GOTO_ARMED = 2,
+	IPTS_FEEDBACK_CMD_TYPE_GOTO_SENSING = 3,
+	IPTS_FEEDBACK_CMD_TYPE_GOTO_SLEEP = 4,
+	IPTS_FEEDBACK_CMD_TYPE_GOTO_DOZE = 5,
+	IPTS_FEEDBACK_CMD_TYPE_HARD_RESET = 6,
+};
+
+/**
+ * enum ipts_feedback_data_type - Describes the data that a feedback buffer contains.
+ * @IPTS_FEEDBACK_DATA_TYPE_VENDOR:        The buffer contains vendor specific feedback.
+ * @IPTS_FEEDBACK_DATA_TYPE_SET_FEATURES:  The buffer contains a HID set features command.
+ * @IPTS_FEEDBACK_DATA_TYPE_GET_FEATURES:  The buffer contains a HID get features command.
+ * @IPTS_FEEDBACK_DATA_TYPE_OUTPUT_REPORT: The buffer contains a HID output report.
+ * @IPTS_FEEDBACK_DATA_TYPE_STORE_DATA:    The buffer contains calibration data for the sensor.
+ */
+enum ipts_feedback_data_type {
+	IPTS_FEEDBACK_DATA_TYPE_VENDOR = 0,
+	IPTS_FEEDBACK_DATA_TYPE_SET_FEATURES = 1,
+	IPTS_FEEDBACK_DATA_TYPE_GET_FEATURES = 2,
+	IPTS_FEEDBACK_DATA_TYPE_OUTPUT_REPORT = 3,
+	IPTS_FEEDBACK_DATA_TYPE_STORE_DATA = 4,
+};
+
+/**
+ * struct ipts_feedback_buffer - The contents of an IPTS feedback buffer.
+ * @cmd_type: A command that should be executed on the sensor.
+ * @size: The size of the payload to be written.
+ * @buffer: The ID of the buffer that contains this feedback data.
+ * @protocol: The protocol version of the EDS.
+ * @data_type: The type of payload that the buffer contains.
+ * @spi_offset: The offset at which to write the payload data.
+ * @payload: Payload for the feedback command, or 0 if no payload is sent.
+ */
+struct ipts_feedback_buffer {
+	enum ipts_feedback_cmd_type cmd_type;
+	u32 size;
+	u32 buffer;
+	u32 protocol;
+	enum ipts_feedback_data_type data_type;
+	u32 spi_offset;
+	u8 reserved[40];
+	u8 payload[];
+} __packed;
+
+/**
+ * enum ipts_reset_type - Possible ways of resetting the touch sensor
+ * @IPTS_RESET_TYPE_HARD: Perform hardware reset using GPIO pin.
+ * @IPTS_RESET_TYPE_SOFT: Perform software reset using SPI interface.
+ */
+enum ipts_reset_type {
+	IPTS_RESET_TYPE_HARD = 0,
+	IPTS_RESET_TYPE_SOFT = 1,
+};
+
+/**
+ * struct ipts_reset_sensor_cmd - Payload for the RESET_SENSOR command.
+ * @type: What type of reset should be performed.
+ */
+struct ipts_reset_sensor_cmd {
+	enum ipts_reset_type type;
+	u8 reserved[4];
+} __packed;
+
+/**
+ * struct ipts_command - A message sent from the host to the ME.
+ * @code:    The message code describing the command. (see IPTS_CMD_*)
+ * @payload: Payload for the command, or 0 if no payload is required.
+ */
+struct ipts_command {
+	u32 code;
+	u8 payload[320];
+} __packed;
+
+/**
+ * struct ipts_device_info - Payload for the GET_DEVICE_INFO response.
+ * @vendor_id:     Vendor ID of the touch sensor.
+ * @device_id:     Device ID of the touch sensor.
+ * @hw_rev:        Hardware revision of the touch sensor.
+ * @fw_rev:        Firmware revision of the touch sensor.
+ * @data_size:     Required size of one data buffer.
+ * @feedback_size: Required size of one feedback buffer.
+ * @mode:          Current operation mode of IPTS.
+ * @max_contacts:  The amount of concurrent touches supported by the sensor.
+ */
+struct ipts_get_device_info_rsp {
+	u16 vendor_id;
+	u16 device_id;
+	u32 hw_rev;
+	u32 fw_rev;
+	u32 data_size;
+	u32 feedback_size;
+	enum ipts_mode mode;
+	u8 max_contacts;
+	u8 reserved[19];
+} __packed;
+
+/**
+ * struct ipts_feedback_rsp - Payload for the FEEDBACK response.
+ * @buffer: The buffer that has received feedback.
+ */
+struct ipts_feedback_rsp {
+	u32 buffer;
+} __packed;
+
+/**
+ * struct ipts_response - A message sent from the ME to the host.
+ * @code:    The message code describing the response. (see IPTS_RSP_*)
+ * @status:  The status code returned by the command.
+ * @payload: Payload returned by the command.
+ */
+struct ipts_response {
+	u32 code;
+	enum ipts_status status;
+	u8 payload[80];
+} __packed;
+
+#define GET_DOORBELL(x) (*(u32*)x->doorbell.address)
+#define GET_BUFF(x) (x->current_doorbell % IPTS_BUFFERS)
+
+#endif /* _IPTS_PROTOCOL_H_ */
diff --git a/drivers/misc/ipts/receiver.c b/drivers/misc/ipts/receiver.c
new file mode 100644
index 000000000000..9a7449b4e167
--- /dev/null
+++ b/drivers/misc/ipts/receiver.c
@@ -0,0 +1,272 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+//#define DEBUG
+#include <linux/mei_cl_bus.h>
+#include <linux/moduleparam.h>
+#include <linux/types.h>
+
+#include "context.h"
+#include "control.h"
+#include "protocol.h"
+#include "resources.h"
+#include "input_data.h"
+#include "receiver.h"
+
+/*
+ * Temporary parameter to guard gen7 multitouch mode.
+ * Remove once gen7 has stable iptsd support.
+ */
+static bool gen7mt;
+module_param(gen7mt, bool, 0644);
+
+static int ipts_receiver_handle_get_device_info(struct ipts_context *ipts,
+						struct ipts_response *rsp)
+{
+	struct ipts_set_mode_cmd cmd;
+
+	memcpy(&ipts->device_info, rsp->payload,
+	       sizeof(struct ipts_get_device_info_rsp));
+  dev_dbg(ipts->dev, "get device_info vendor_id:0x%x, device_id:0x%x, hw_rev:%u, fw_rev:%u, data_size:%u, feedback_size:%u, ipts_mode:%u, max contacts:%u\n", 
+    ipts->device_info.vendor_id,ipts->device_info.device_id, ipts->device_info.hw_rev, ipts->device_info.fw_rev, ipts->device_info.data_size, ipts->device_info.feedback_size,
+    ipts->device_info.mode, ipts->device_info.max_contacts);
+	memset(&cmd, 0, sizeof(struct ipts_set_mode_cmd));
+	cmd.mode = IPTS_MODE_MULTITOUCH;
+
+  if (!devmode && ipts->touch_dev == NULL) {
+    if(init_input_devices(ipts)) {
+      dev_err(ipts->dev, "Error to create input device for ipts\n");
+      devmode = true;
+    }
+  }
+
+	return ipts_control_send(ipts, IPTS_CMD_SET_MODE, &cmd,
+				 sizeof(struct ipts_set_mode_cmd));
+}
+
+static int ipts_receiver_handle_set_mode(struct ipts_context *ipts)
+{
+	int i, ret;
+	struct ipts_set_mem_window_cmd cmd;
+
+	ret = ipts_resources_alloc(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to allocate resources\n");
+		return ret;
+	}
+
+	memset(&cmd, 0, sizeof(struct ipts_set_mem_window_cmd));
+
+	for (i = 0; i < IPTS_BUFFERS; i++) {
+		cmd.data_buffer_addr_lower[i] =
+			lower_32_bits(ipts->data[i].dma_address);
+
+		cmd.data_buffer_addr_upper[i] =
+			upper_32_bits(ipts->data[i].dma_address);
+
+		cmd.feedback_buffer_addr_lower[i] =
+			lower_32_bits(ipts->feedback[i].dma_address);
+
+		cmd.feedback_buffer_addr_upper[i] =
+			upper_32_bits(ipts->feedback[i].dma_address);
+	}
+
+	cmd.workqueue_addr_lower = lower_32_bits(ipts->workqueue.dma_address);
+	cmd.workqueue_addr_upper = upper_32_bits(ipts->workqueue.dma_address);
+
+	cmd.doorbell_addr_lower = lower_32_bits(ipts->doorbell.dma_address);
+	cmd.doorbell_addr_upper = upper_32_bits(ipts->doorbell.dma_address);
+
+	cmd.host2me_addr_lower = lower_32_bits(ipts->host2me.dma_address);
+	cmd.host2me_addr_upper = upper_32_bits(ipts->host2me.dma_address);
+
+	cmd.workqueue_size = IPTS_WORKQUEUE_SIZE;
+	cmd.workqueue_item_size = IPTS_WORKQUEUE_ITEM_SIZE;
+
+	return ipts_control_send(ipts, IPTS_CMD_SET_MEM_WINDOW, &cmd,
+				 sizeof(struct ipts_set_mem_window_cmd));
+}
+
+static int ipts_receiver_handle_set_mem_window(struct ipts_context *ipts)
+{
+	int ret;
+
+	dev_info(ipts->dev, "Device %04hX:%04hX ready\n",
+		 ipts->device_info.vendor_id, ipts->device_info.device_id);
+	ipts->status = IPTS_HOST_STATUS_STARTED;
+
+	ret = ipts_control_send(ipts, IPTS_CMD_READY_FOR_DATA, NULL, 0);
+	if (ret)
+		return ret;
+  if (!devmode) { 
+    dev_dbg(ipts->dev, "Begin data request...");
+    ipts->request_status = IPTS_REQUEST_FRAME;
+    schedule_delayed_work(&ipts->request_work, INIT_IPTS_TIMEOUT);
+  }
+	if (!gen7mt)
+		return 0;
+
+	return ipts_control_set_feature(ipts, 0x5, 0x1);
+}
+
+static int ipts_receiver_handle_feedback(struct ipts_context *ipts,
+					 struct ipts_response *rsp)
+{
+	struct ipts_feedback_rsp *feedback = (struct ipts_feedback_rsp *) rsp->payload;
+
+  dev_dbg(ipts->dev,"resp feedback:%u\n", feedback->buffer);
+	if (ipts->status != IPTS_HOST_STATUS_STOPPING)
+		return 0;
+
+	if (feedback->buffer < IPTS_BUFFERS - 1)
+		return ipts_control_send_feedback(ipts, feedback->buffer + 1);
+
+	return ipts_control_send(ipts, IPTS_CMD_CLEAR_MEM_WINDOW, NULL, 0);
+}
+
+static int ipts_receiver_handle_clear_mem_window(struct ipts_context *ipts)
+{
+	ipts->status = IPTS_HOST_STATUS_STOPPED;
+
+	if (ipts->restart)
+		return ipts_control_start(ipts);
+
+	return 0;
+}
+
+static bool ipts_receiver_sensor_was_reset(u32 status)
+{
+	return status == IPTS_STATUS_SENSOR_EXPECTED_RESET ||
+	       status == IPTS_STATUS_SENSOR_UNEXPECTED_RESET;
+}
+
+static bool ipts_receiver_handle_error(struct ipts_context *ipts,
+				       struct ipts_response *rsp)
+{
+	bool error;
+
+	switch (rsp->status) {
+	case IPTS_STATUS_SUCCESS:
+	case IPTS_STATUS_COMPAT_CHECK_FAIL:
+		error = false;
+		break;
+	case IPTS_STATUS_INVALID_PARAMS:
+		error = rsp->code != IPTS_RSP_FEEDBACK;
+		break;
+	case IPTS_STATUS_SENSOR_DISABLED:
+		error = ipts->status != IPTS_HOST_STATUS_STOPPING;
+		break;
+	default:
+		error = true;
+		break;
+	}
+
+	if (!error)
+		return false;
+
+	dev_err(ipts->dev, "Command 0x%08x failed: %d\n", rsp->code,
+		rsp->status);
+
+	if (ipts_receiver_sensor_was_reset(rsp->status)) {
+		dev_err(ipts->dev, "Sensor was reset\n");
+
+		if (ipts_control_restart(ipts))
+			dev_err(ipts->dev, "Failed to restart IPTS\n");
+	}
+
+	return true;
+}
+
+static void ipts_receiver_handle_response(struct ipts_context *ipts,
+					  struct ipts_response *rsp)
+{
+	int ret;
+  dev_dbg(ipts->dev, "response: code:0x%x, status:%d", rsp->code, rsp->status);
+	if (ipts_receiver_handle_error(ipts, rsp))
+		return;
+
+	switch (rsp->code) {
+	case IPTS_RSP_GET_DEVICE_INFO:
+		ret = ipts_receiver_handle_get_device_info(ipts, rsp);
+		break;
+	case IPTS_RSP_SET_MODE:
+		ret = ipts_receiver_handle_set_mode(ipts);
+		break;
+	case IPTS_RSP_SET_MEM_WINDOW:
+		ret = ipts_receiver_handle_set_mem_window(ipts);
+		break;
+	case IPTS_RSP_FEEDBACK:
+		ret = ipts_receiver_handle_feedback(ipts, rsp);
+		break;
+	case IPTS_RSP_CLEAR_MEM_WINDOW:
+		ret = ipts_receiver_handle_clear_mem_window(ipts);
+		break;
+	default:
+		ret = 0;
+		break;
+	}
+
+	if (!ret)
+		return;
+
+	dev_err(ipts->dev, "Error while handling response 0x%08x: %d\n",
+		rsp->code, ret);
+
+	if (ipts_control_stop(ipts))
+		dev_err(ipts->dev, "Failed to stop IPTS\n");
+}
+
+void ipts_receiver_callback(struct mei_cl_device *cldev)
+{
+	int ret;
+	struct ipts_response rsp;
+	struct ipts_context *ipts;
+
+	ipts = mei_cldev_get_drvdata(cldev);
+
+	ret = mei_cldev_recv(cldev, (u8 *)&rsp, sizeof(struct ipts_response));
+	if (ret <= 0) {
+		dev_err(ipts->dev, "Error while reading response: %d\n", ret);
+		return;
+	}
+
+	ipts_receiver_handle_response(ipts, &rsp);
+}
+
+void ipts_mei_notif(struct mei_cl_device *cldev) 
+{
+  struct ipts_context *ipts;
+  u32 doorbell;
+  int diff, i;
+
+  ipts = mei_cldev_get_drvdata(cldev);
+  if (ipts->doorbell.address == NULL) {
+     dev_dbg(ipts->dev, "no doorbell set.\n");
+     return;
+  }
+  doorbell = *(u32 *)ipts->doorbell.address;
+  diff = doorbell - ipts->current_doorbell;
+  dev_dbg(ipts->dev, "Hardware nofity, doorbell:%u , current:%u\n", 
+      doorbell, ipts->current_doorbell);
+  if (diff < 0) {
+    dev_dbg(ipts->dev, "doorbell reset.\n");
+    ipts->current_doorbell = 0;
+  } else {
+    for (i = 0; i < diff; i++) {
+      ipts->current_doorbell++;
+      ipts_control_send_feedback(ipts, (ipts->current_doorbell % IPTS_BUFFERS));
+      dev_dbg(ipts->dev, "doorbell feedback:%u\n", ipts->current_doorbell);
+    }
+  }
+}
+
+void ipts_receiver_flush(struct ipts_context *ipts) {
+  int i;
+  for (i = 0 ; i < IPTS_BUFFERS; i++) {
+     ipts_control_send_feedback(ipts, i);
+  }
+}
diff --git a/drivers/misc/ipts/receiver.h b/drivers/misc/ipts/receiver.h
new file mode 100644
index 000000000000..e1f8a24fe96f
--- /dev/null
+++ b/drivers/misc/ipts/receiver.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef _IPTS_RECEIVER_H_
+#define _IPTS_RECEIVER_H_
+
+#include <linux/mei_cl_bus.h>
+void ipts_receiver_callback(struct mei_cl_device *cldev);
+void ipts_mei_notif(struct mei_cl_device *cldev);
+void ipts_receiver_flush(struct ipts_context *ipts);
+
+#endif /* _IPTS_RECEIVER_H_ */
diff --git a/drivers/misc/ipts/resources.c b/drivers/misc/ipts/resources.c
new file mode 100644
index 000000000000..8e3a2409e438
--- /dev/null
+++ b/drivers/misc/ipts/resources.c
@@ -0,0 +1,128 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/dma-mapping.h>
+
+#include "context.h"
+
+void ipts_resources_free(struct ipts_context *ipts)
+{
+	int i;
+	struct ipts_buffer_info *buffers;
+
+	u32 data_buffer_size = ipts->device_info.data_size;
+	u32 feedback_buffer_size = ipts->device_info.feedback_size;
+
+	buffers = ipts->data;
+	for (i = 0; i < IPTS_BUFFERS; i++) {
+		if (!buffers[i].address)
+			continue;
+
+		dma_free_coherent(ipts->dev, data_buffer_size,
+				  buffers[i].address, buffers[i].dma_address);
+
+		buffers[i].address = NULL;
+		buffers[i].dma_address = 0;
+	}
+
+	buffers = ipts->feedback;
+	for (i = 0; i < IPTS_BUFFERS; i++) {
+		if (!buffers[i].address)
+			continue;
+
+		dma_free_coherent(ipts->dev, feedback_buffer_size,
+				  buffers[i].address, buffers[i].dma_address);
+
+		buffers[i].address = NULL;
+		buffers[i].dma_address = 0;
+	}
+
+	if (ipts->doorbell.address) {
+		dma_free_coherent(ipts->dev, sizeof(u32),
+				  ipts->doorbell.address,
+				  ipts->doorbell.dma_address);
+
+		ipts->doorbell.address = NULL;
+		ipts->doorbell.dma_address = 0;
+	}
+
+	if (ipts->workqueue.address) {
+		dma_free_coherent(ipts->dev, sizeof(u32),
+				  ipts->workqueue.address,
+				  ipts->workqueue.dma_address);
+
+		ipts->workqueue.address = NULL;
+		ipts->workqueue.dma_address = 0;
+	}
+
+	if (ipts->host2me.address) {
+		dma_free_coherent(ipts->dev, feedback_buffer_size,
+				  ipts->host2me.address,
+				  ipts->host2me.dma_address);
+
+		ipts->host2me.address = NULL;
+		ipts->host2me.dma_address = 0;
+	}
+}
+
+int ipts_resources_alloc(struct ipts_context *ipts)
+{
+	int i;
+	struct ipts_buffer_info *buffers;
+
+	u32 data_buffer_size = ipts->device_info.data_size;
+	u32 feedback_buffer_size = ipts->device_info.feedback_size;
+
+	buffers = ipts->data;
+	for (i = 0; i < IPTS_BUFFERS; i++) {
+		buffers[i].address =
+			dma_alloc_coherent(ipts->dev, data_buffer_size,
+					   &buffers[i].dma_address, GFP_KERNEL);
+
+		if (!buffers[i].address)
+			goto release_resources;
+	}
+
+	buffers = ipts->feedback;
+	for (i = 0; i < IPTS_BUFFERS; i++) {
+		buffers[i].address =
+			dma_alloc_coherent(ipts->dev, feedback_buffer_size,
+					   &buffers[i].dma_address, GFP_KERNEL);
+
+		if (!buffers[i].address)
+			goto release_resources;
+	}
+
+	ipts->doorbell.address =
+		dma_alloc_coherent(ipts->dev, sizeof(u32),
+				   &ipts->doorbell.dma_address, GFP_KERNEL);
+
+	if (!ipts->doorbell.address)
+		goto release_resources;
+
+	ipts->workqueue.address =
+		dma_alloc_coherent(ipts->dev, sizeof(u32),
+				   &ipts->workqueue.dma_address, GFP_KERNEL);
+
+	if (!ipts->workqueue.address)
+		goto release_resources;
+
+	ipts->host2me.address =
+		dma_alloc_coherent(ipts->dev, feedback_buffer_size,
+				   &ipts->host2me.dma_address, GFP_KERNEL);
+
+	if (!ipts->workqueue.address)
+		goto release_resources;
+
+	return 0;
+
+release_resources:
+
+	ipts_resources_free(ipts);
+	return -ENOMEM;
+}
diff --git a/drivers/misc/ipts/resources.h b/drivers/misc/ipts/resources.h
new file mode 100644
index 000000000000..fdac0eee9156
--- /dev/null
+++ b/drivers/misc/ipts/resources.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef _IPTS_RESOURCES_H_
+#define _IPTS_RESOURCES_H_
+
+#include "context.h"
+
+int ipts_resources_alloc(struct ipts_context *ipts);
+void ipts_resources_free(struct ipts_context *ipts);
+
+#endif /* _IPTS_RESOURCES_H_ */
diff --git a/drivers/misc/ipts/touch-processing.c b/drivers/misc/ipts/touch-processing.c
new file mode 100644
index 000000000000..ae49b85df3bf
--- /dev/null
+++ b/drivers/misc/ipts/touch-processing.c
@@ -0,0 +1,104 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include "contact.h"
+#include "heatmap.h"
+#include "protocol.h"
+#include "touch-processing.h"
+#include "math.h"
+#include "input_data.h"
+
+#define STABLE_CONTACT_AREA 5
+
+void iptsd_touch_processing_inputs(struct iptsd_touch_processor *tp, struct heatmap *hm)
+{
+	int x, y, i;
+
+  heatmap_average(hm);
+	tp->touch_count = contacts_get(hm, tp->last_hm, tp->contacts, tp->device_info->max_contacts);
+  if (tp->touch_count == 0 && tp->last_hm->touch_count != 0)
+    tp->filter_out = FILTER_OUT(hm, tp->last_hm);
+  else
+    tp->filter_out = false;
+#ifdef DEBUG
+  pr_info("Get %d contacts.\n", tp->touch_count);
+#endif
+	for (i = 0; i < tp->device_info->max_contacts; i++) {
+    if (i < tp->touch_count) {
+      x = tp->contacts[i].x;
+      y = tp->contacts[i].y;
+      
+      if (tp->config->invert_x)
+        x = hm->width * 100 - x;
+      if (tp->config->invert_y)
+        y = hm->height * 100 - y;
+      
+  		tp->inputs[i].x = fix_zoom(x, hm->width * 100, IPTS_MAX_X);
+  		tp->inputs[i].y = fix_zoom(y, hm->height * 100, IPTS_MAX_Y);
+      tp->inputs[i].major = fix_zoom(tp->contacts[i].major, hm->diagonal, IPTS_DIAGONAL);
+      tp->inputs[i].pressure = tp->contacts[i].max_v;
+    }
+		tp->inputs[i].index = tp->contacts[i].index;
+		tp->inputs[i].slot = tp->contacts[i].slot;
+    tp->inputs[i].area = tp->contacts[i].area;
+		tp->inputs[i].is_stable = tp->contacts[i].area >= STABLE_CONTACT_AREA;
+		tp->inputs[i].contact = &tp->contacts[i];
+#ifdef DEBUG
+    pr_info("Raw data: slot:%d,index:%d, contact(%d,%d), revert(%d,%d),output(%d,%d)\n", 
+        tp->inputs[i].slot, tp->inputs[i].index, 
+        tp->contacts[i].x,tp->contacts[i].y, x,y, tp->inputs[i].x,tp->inputs[i].y);
+#endif
+	}
+#ifdef DEBUG
+  pr_info("filter_out:%d, bell_intervals:%u\n", tp->filter_out, hm->bell - tp->last_hm->bell);
+#endif
+}
+
+struct heatmap *iptsd_touch_processing_get_heatmap(struct iptsd_touch_processor *tp, int w, int h)
+{
+  struct heatmap *tmp_hm = tp->hm;
+  if(!tp->filter_out) {
+    tp->hm = tp->last_hm;
+    tp->last_hm = tmp_hm;
+  }
+	if(heatmap_init(tp->hm, w, h, tp->config->touch_threshold)){
+    pr_err("No memory for heatmap\n");
+  };
+
+	return tp->hm;
+}
+
+int iptsd_touch_processing_init(struct iptsd_touch_processor *tp)
+{
+	int  max_contacts = tp->device_info->max_contacts;
+  tp->hm = kmalloc(sizeof(struct heatmap), GFP_KERNEL);
+  if (!tp->hm)
+    return -ENOMEM;
+  tp->hm->data = NULL;
+  tp->hm->visited = NULL;
+  tp->last_hm = kmalloc(sizeof(struct heatmap), GFP_KERNEL);
+  if (!tp->last_hm)
+    return -ENOMEM;
+  tp->last_hm->data = NULL;
+  tp->last_hm->visited = NULL;
+	tp->contacts = kmalloc(max_contacts * sizeof(struct contact), GFP_KERNEL);
+	if (!tp->contacts)
+		return -ENOMEM;
+
+	tp->inputs = kzalloc(max_contacts * sizeof(struct iptsd_touch_input), GFP_KERNEL);
+	if (!tp->inputs)
+		return -ENOMEM;
+
+	return 0;
+}
+
+void iptsd_touch_processing_free(struct iptsd_touch_processor *tp)
+{
+	if (tp->contacts)
+		kfree(tp->contacts);
+
+	if (tp->inputs)
+		kfree(tp->inputs);
+  release_heatmap(tp->hm);
+  release_heatmap(tp->last_hm);
+}
diff --git a/drivers/misc/ipts/touch-processing.h b/drivers/misc/ipts/touch-processing.h
new file mode 100644
index 000000000000..f11eec37b416
--- /dev/null
+++ b/drivers/misc/ipts/touch-processing.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTSD_TOUCH_PROCESSING_H_
+#define _IPTSD_TOUCH_PROCESSING_H_
+
+#include <linux/types.h>
+
+#include "heatmap.h"
+#include "protocol.h"
+#include "config.h"
+#include "contact.h"
+
+#define IPTSD_MAX_STYLI 10
+#define BELL_THRESHOLD 1
+#define FILTER_OUT(a,b) (a->bell-b->bell)<BELL_THRESHOLD
+
+struct iptsd_touch_input {
+	int x;
+	int y;
+	int area;
+	int index;
+	int slot;
+  int major;
+	bool is_stable;
+  int pressure;
+	struct contact *contact;
+};
+
+struct iptsd_touch_processor {
+  uint8_t touch_count;
+  bool filter_out;
+	struct heatmap *hm;
+  struct heatmap *last_hm;
+	struct contact *contacts;
+	struct iptsd_touch_input *inputs;
+
+	struct surface_touch_config *config;
+	struct ipts_get_device_info_rsp *device_info;
+};
+
+//double iptsd_touch_processing_dist(struct iptsd_touch_input *input, struct iptsd_touch_input *other);
+void iptsd_touch_processing_inputs(struct iptsd_touch_processor *tp, struct heatmap *hm);
+struct heatmap *iptsd_touch_processing_get_heatmap(struct iptsd_touch_processor *tp, int w, int h);
+int iptsd_touch_processing_init(struct iptsd_touch_processor *tp);
+void iptsd_touch_processing_free(struct iptsd_touch_processor *tp);
+
+#endif /* _IPTSD_TOUCH_PROCESSING_H_ */
diff --git a/drivers/misc/ipts/uapi.c b/drivers/misc/ipts/uapi.c
new file mode 100644
index 000000000000..4ef8b0168752
--- /dev/null
+++ b/drivers/misc/ipts/uapi.c
@@ -0,0 +1,207 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+
+#include "context.h"
+#include "control.h"
+#include "protocol.h"
+#include "uapi.h"
+
+struct ipts_uapi uapi;
+
+static ssize_t ipts_uapi_read(struct file *file, char __user *buf, size_t count,
+			      loff_t *offset)
+{
+	int buffer;
+	int maxbytes;
+	struct ipts_context *ipts = uapi.ipts;
+
+	buffer = MINOR(file->f_path.dentry->d_inode->i_rdev);
+
+	if (!ipts || ipts->status != IPTS_HOST_STATUS_STARTED)
+		return -ENODEV;
+
+	maxbytes = ipts->device_info.data_size - *offset;
+	if (maxbytes <= 0 || count > maxbytes)
+		return -EINVAL;
+
+	if (copy_to_user(buf, ipts->data[buffer].address + *offset, count))
+		return -EFAULT;
+
+	return count;
+}
+
+static long ipts_uapi_ioctl_get_device_ready(struct ipts_context *ipts,
+					     unsigned long arg)
+{
+	void __user *buffer = (void __user *)arg;
+	u8 ready = 0;
+
+	if (ipts)
+		ready = ipts->status == IPTS_HOST_STATUS_STARTED;
+
+	if (copy_to_user(buffer, &ready, sizeof(u8)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static long ipts_uapi_ioctl_get_device_info(struct ipts_context *ipts,
+					    unsigned long arg)
+{
+	struct ipts_device_info info;
+	void __user *buffer = (void __user *)arg;
+
+	if (!ipts || ipts->status != IPTS_HOST_STATUS_STARTED)
+		return -ENODEV;
+
+	info.vendor = ipts->device_info.vendor_id;
+	info.product = ipts->device_info.device_id;
+	info.version = ipts->device_info.fw_rev;
+	info.buffer_size = ipts->device_info.data_size;
+	info.max_contacts = ipts->device_info.max_contacts;
+
+	if (copy_to_user(buffer, &info, sizeof(struct ipts_device_info)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static long ipts_uapi_ioctl_get_doorbell(struct ipts_context *ipts,
+					 unsigned long arg)
+{
+	void __user *buffer = (void __user *)arg;
+
+	if (!ipts || ipts->status != IPTS_HOST_STATUS_STARTED)
+		return -ENODEV;
+
+	if (copy_to_user(buffer, ipts->doorbell.address, sizeof(u32)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static long ipts_uapi_ioctl_send_feedback(struct ipts_context *ipts,
+					  struct file *file)
+{
+	int ret;
+	u32 buffer;
+
+	if (!ipts || ipts->status != IPTS_HOST_STATUS_STARTED)
+		return -ENODEV;
+
+	buffer = MINOR(file->f_path.dentry->d_inode->i_rdev);
+  dev_dbg(ipts->dev, "Userland feedback buffer:%u\n", buffer);
+	ret = ipts_control_send_feedback(ipts, buffer);
+	if (ret)
+		return -EFAULT;
+
+	return 0;
+}
+
+static long ipts_uapi_ioctl_send_reset(struct ipts_context *ipts)
+{
+	int ret;
+	struct ipts_reset_sensor_cmd cmd;
+
+	if (!ipts || ipts->status != IPTS_HOST_STATUS_STARTED)
+		return -ENODEV;
+
+	memset(&cmd, 0, sizeof(struct ipts_reset_sensor_cmd));
+	cmd.type = IPTS_RESET_TYPE_SOFT;
+
+	ret = ipts_control_send(ipts, IPTS_CMD_RESET_SENSOR, &cmd,
+				sizeof(struct ipts_reset_sensor_cmd));
+
+	if (ret)
+		return -EFAULT;
+
+	return 0;
+}
+
+static long ipts_uapi_ioctl(struct file *file, unsigned int cmd,
+			    unsigned long arg)
+{
+	struct ipts_context *ipts = uapi.ipts;
+
+	switch (cmd) {
+	case IPTS_IOCTL_GET_DEVICE_READY:
+		return ipts_uapi_ioctl_get_device_ready(ipts, arg);
+	case IPTS_IOCTL_GET_DEVICE_INFO:
+		return ipts_uapi_ioctl_get_device_info(ipts, arg);
+	case IPTS_IOCTL_GET_DOORBELL:
+		return ipts_uapi_ioctl_get_doorbell(ipts, arg);
+	case IPTS_IOCTL_SEND_FEEDBACK:
+		return ipts_uapi_ioctl_send_feedback(ipts, file);
+	case IPTS_IOCTL_SEND_RESET:
+		return ipts_uapi_ioctl_send_reset(ipts);
+	default:
+		return -ENOTTY;
+	}
+}
+
+static const struct file_operations ipts_uapi_fops = {
+	.owner = THIS_MODULE,
+	.read = ipts_uapi_read,
+	.unlocked_ioctl = ipts_uapi_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = ipts_uapi_ioctl,
+#endif
+};
+
+void ipts_uapi_link(struct ipts_context *ipts)
+{
+	uapi.ipts = ipts;
+}
+
+void ipts_uapi_unlink(void)
+{
+	uapi.ipts = NULL;
+}
+
+int ipts_uapi_init(void)
+{
+	int i, major;
+
+	alloc_chrdev_region(&uapi.dev, 0, IPTS_BUFFERS, "ipts");
+	uapi.class = class_create(THIS_MODULE, "ipts");
+
+	major = MAJOR(uapi.dev);
+
+	cdev_init(&uapi.cdev, &ipts_uapi_fops);
+	uapi.cdev.owner = THIS_MODULE;
+	cdev_add(&uapi.cdev, MKDEV(major, 0), IPTS_BUFFERS);
+
+	for (i = 0; i < IPTS_BUFFERS; i++) {
+		device_create(uapi.class, NULL, MKDEV(major, i), NULL,
+			      "ipts/%d", i);
+	}
+
+	return 0;
+}
+
+void ipts_uapi_free(void)
+{
+	int i;
+	int major;
+
+	major = MAJOR(uapi.dev);
+
+	for (i = 0; i < IPTS_BUFFERS; i++)
+		device_destroy(uapi.class, MKDEV(major, i));
+
+	cdev_del(&uapi.cdev);
+
+	unregister_chrdev_region(MKDEV(major, 0), MINORMASK);
+	class_destroy(uapi.class);
+}
diff --git a/drivers/misc/ipts/uapi.h b/drivers/misc/ipts/uapi.h
new file mode 100644
index 000000000000..53fb86a88f97
--- /dev/null
+++ b/drivers/misc/ipts/uapi.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef _IPTS_UAPI_H_
+#define _IPTS_UAPI_H_
+
+#include <linux/types.h>
+
+#include "context.h"
+
+struct ipts_uapi {
+	dev_t dev;
+	struct class *class;
+	struct cdev cdev;
+
+	struct ipts_context *ipts;
+};
+
+struct ipts_device_info {
+	__u16 vendor;
+	__u16 product;
+	__u32 version;
+	__u32 buffer_size;
+	__u8 max_contacts;
+
+	/* For future expansion */
+	__u8 reserved[19];
+};
+
+#define IPTS_IOCTL_GET_DEVICE_READY _IOR(0x86, 0x01, __u8)
+#define IPTS_IOCTL_GET_DEVICE_INFO  _IOR(0x86, 0x02, struct ipts_device_info)
+#define IPTS_IOCTL_GET_DOORBELL	    _IOR(0x86, 0x03, __u32)
+#define IPTS_IOCTL_SEND_FEEDBACK    _IO(0x86, 0x04)
+#define IPTS_IOCTL_SEND_RESET	    _IO(0x86, 0x05)
+
+void ipts_uapi_link(struct ipts_context *ipts);
+void ipts_uapi_unlink(void);
+
+int ipts_uapi_init(void);
+void ipts_uapi_free(void);
+
+#endif /* _IPTS_UAPI_H_ */
diff --git a/drivers/misc/mei/hw-me-regs.h b/drivers/misc/mei/hw-me-regs.h
index 9cf8d8f60cfe..ca2d4faff6a2 100644
--- a/drivers/misc/mei/hw-me-regs.h
+++ b/drivers/misc/mei/hw-me-regs.h
@@ -92,6 +92,7 @@
 #define MEI_DEV_ID_CDF        0x18D3  /* Cedar Fork */
 
 #define MEI_DEV_ID_ICP_LP     0x34E0  /* Ice Lake Point LP */
+#define MEI_DEV_ID_ICP_LP_3   0x34E4  /* Ice Lake Point LP 3 (iTouch) */
 
 #define MEI_DEV_ID_JSP_N      0x4DE0  /* Jasper Lake Point N */
 
diff --git a/drivers/misc/mei/init.c b/drivers/misc/mei/init.c
index bcee77768b91..21ed765003e1 100644
--- a/drivers/misc/mei/init.c
+++ b/drivers/misc/mei/init.c
@@ -302,10 +302,10 @@ void mei_stop(struct mei_device *dev)
 {
 	dev_dbg(dev->dev, "stopping the device.\n");
 
+	mei_cl_bus_remove_devices(dev);
 	mutex_lock(&dev->device_lock);
 	mei_set_devstate(dev, MEI_DEV_POWER_DOWN);
 	mutex_unlock(&dev->device_lock);
-	mei_cl_bus_remove_devices(dev);
 
 	mei_cancel_work(dev);
 
diff --git a/drivers/misc/mei/pci-me.c b/drivers/misc/mei/pci-me.c
index 1de9ef7a272b..e12484840f88 100644
--- a/drivers/misc/mei/pci-me.c
+++ b/drivers/misc/mei/pci-me.c
@@ -96,6 +96,7 @@ static const struct pci_device_id mei_me_pci_tbl[] = {
 	{MEI_PCI_DEVICE(MEI_DEV_ID_CMP_H_3, MEI_ME_PCH8_ITOUCH_CFG)},
 
 	{MEI_PCI_DEVICE(MEI_DEV_ID_ICP_LP, MEI_ME_PCH12_CFG)},
+	{MEI_PCI_DEVICE(MEI_DEV_ID_ICP_LP_3, MEI_ME_PCH12_CFG)},
 
 	{MEI_PCI_DEVICE(MEI_DEV_ID_TGP_LP, MEI_ME_PCH15_CFG)},
 	{MEI_PCI_DEVICE(MEI_DEV_ID_TGP_H, MEI_ME_PCH15_SPS_CFG)},
